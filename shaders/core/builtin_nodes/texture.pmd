---
node: texture2D
input: { name: "Map", type: "sampler2D", visible: false }
input: { name: "UV",  type: "vec2" }
---

#```{ name:"Declaration", type:"text", visible: false}
#uniform sampler2D tex$texture:assign$;
#
#```

```{ name:"Initialization", type:"text", restrict:"fshader", visible: false}
  vec4 $Map:assign$_val = texture2D( $Map:assign$, $UV:assign$.xy );

```

#Color 
```{name:"Color", type:"color4", restrict:"fshader,assign"}
$Map:assign$_val
```

```{name:"Color", type:"color4", restrict:"vshader,assign"}
texture2D( $Map:assign$, $UV:assign$.xy )
```
#Normal
 
```{name:"Normal", type:"vec4", restrict:"fshader,assign"}
vec4( 2.0 * $Map:assign$_val.rgb - vec3(1.0, 1.0, 1.0), 1 )
```

```{name:"Normal", type:"vec4", restrict:"vshader,assign"}
vec4( 2.0 * texture2D( $Map:assign$, $UV:assign$.xy ).rgb - vec3(1.0, 1.0, 1.0), 1 )
```
```{name:"Texture", type:"sampler2D", restrict:"assign"}
$Map:assign$
```

---
node: texture2DLod
input: { name: "Map",    type: "sampler2D", visible: false }
input: { name: "UV",     type: "vec2" }
input: { name: "Level",  type: "float" }
---

#```{ name:"Declaration", type:"text", visible: false}
#uniform sampler2D tex$texture:assign$;
#
#```

```{ name:"Initialization", type:"text", restrict:"fshader", visible: false}
  vec4 $Map:assign$_val = textureLod( $Map:assign$, $UV:assign$.xy, $Level:assign$ );

```

#Color 
```{name:"Color", type:"color4", restrict:"fshader,assign"}
$Map:assign$_val
```

```{name:"Color", type:"color4", restrict:"vshader,assign"}
textureLod( $Map:assign$, $UV:assign$.xy, $Level:assign$ )
```
#Normal
 
```{name:"Normal", type:"vec4", restrict:"fshader,assign"}
vec4( 2.0 * $Map:assign$_val.rgb - vec3(1.0, 1.0, 1.0), 1 )
```

```{name:"Normal", type:"vec4", restrict:"vshader,assign"}
vec4( 2.0 * textureLod( $Map:assign$, $UV:assign$.xy, $Level:assign$ ).rgb - vec3(1.0, 1.0, 1.0), 1 )
```
```{name:"Texture", type:"sampler2D", restrict:"assign"}
$Map:assign$
```
---
node: perturb_normal_world
input: { name:"Normal", type:"vec3" }
---

#Normal
```{name:"Normal", type:"vec3", restrict:"assign"}
CalcBumpedNormal( vWorldNormal.xyz, vWorldTangent.xyz, vWorldCotangent.xyz, $Normal:assign$ )
```

```{name:"Initialization", restrict:"vshader", visible:false}
  vWorldTangent = world * vec4( Tangent.xyz, 0 );
  vWorldCotangent = world * vec4( Cotangent.xyz, 0 );
  vTangent = view * vec4( vWorldTangent.xyz, 0 );
  vCotangent = view * vec4( vWorldCotangent.xyz, 0 );

```

```{name:"Declaration", type:"text", visible:false}

vec3 CalcBumpedNormal( vec3 Normal, vec3 Tangent, vec3 Cotangent, vec3 BumpMapNormal )
{
  vec4 NewNormal = normalize( vec4( BumpMapNormal.xyz, 0 ));
  mat3 TBN = mat3( Tangent.xyz, Cotangent.xyz, Normal.xyz );
  NewNormal = vec4( TBN * NewNormal.xyz, 0 );
  NewNormal = normalize( NewNormal );
  return NewNormal.xyz;
}

```

```{restrict:"vshader"}
IN vec4 Tangent;
IN vec4 Cotangent;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vWorldTangent;
OUT vec4 vWorldCotangent;


```

```{restrict:"fshader"}
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vWorldTangent;
IN vec4 vWorldCotangent;

```

---
node: spherical_mapping
input: { name:"Normal", type:"vec3" }
---


```{name:"Declaration", type:"text", visible:false}
const vec2 invAtan = vec2(0.1591, 0.3183);
vec4 SampleSphericalMap(vec3 v)
{
  vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
  uv *= invAtan;
  uv += 0.5;
  return vec4( uv, 0, 0 );
}

```

```{name:"UV", type:"vec2"}
SampleSphericalMap( normalize( $Normal:assign$.xyz ))
```

---
node: inv_spherical_mapping
input: { name:"UV", type:"vec2" }
---


```{name:"Declaration", type:"text", visible:false}
const float PI = 3.1415926535897932384626433832795028841971693993751058209749;

vec2 toUV(in vec3 n)
{
    vec2 uv;

    uv.x = atan(-n.x, n.y);
    uv.x = (uv.x + PI / 2.0) / (PI * 2.0) + PI * (28.670 / 360.0);

    uv.y = acos(n.z) / PI;

    return uv;
}

// Uv range: [0, 1]
vec3 toPolar(in vec2 uv)
{
    float theta = 2.0 * PI * uv.x + - PI / 2.0;
    float phi = PI * uv.y;

    vec3 n;
    n.x = cos(theta) * sin(phi);
    n.y = sin(theta) * sin(phi);
    n.z = cos(phi);

    //n = normalize(n);
    return n;
}

```

```{name:"Normal", type:"vec3"}
toPolar( $UV:assign$ )
```
---
node: convolute_environment
input: { name:"texture", type:"sampler2D" }
---

```{name:"Initialization", type:"text", restrict:"fshader", visible:false}
  const float PI = 3.14159265359;
  // The world vector acts as the normal of a tangent surface
  // from the origin, aligned to WorldPos. Given this normal, calculate all
  // incoming radiance of the environment. The result of this radiance
  // is the radiance of light coming from -Normal direction, which is what
  // we use in the PBR shader to sample irradiance.
  vec3 N = normalize( -vObjectPosition.xyz );

  vec3 irradiance = vec3(0.0);   
  
  // tangent space calculation from origin point
  vec3 up    = vec3( 0.0, 1.0, 0.0 );
  vec3 right = cross( up, vNormal.xyz );
  up         = cross( vNormal.xyz, right );
     
  float sampleDelta = 0.025;
  float nrSamples = 0.0;

  // tangent space to world
  /*vec3 sampleVec = N; 
  const vec2 invAtan = vec2( 0.1591, 0.3183 );
  vec2 uv = vec2( atan( sampleVec.z, sampleVec.x ), asin( sampleVec.y ));
  uv *= invAtan;
  uv += 0.5;

  irradiance += texture2D( $texture:assign$, uv ).rgb;*/
  
  for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)
  {
      for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)
      {
          // spherical to cartesian (in tangent space)
          vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));
          // tangent space to world
          vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; 
          const vec2 invAtan = vec2( 0.1591, 0.3183 );
          vec2 uv = vec2( atan( sampleVec.z, sampleVec.x ), 1-asin( sampleVec.y ));
          //uv *= invAtan;
          //uv += 0.5;

          irradiance += texture2D( $texture:assign$, uv ).rgb * cos(theta) * sin(theta);
          nrSamples++;
      }
  }
  irradiance = PI * irradiance * (1.0 / float(nrSamples));

```

```{name:"Color", type:"color4", restrict:"assign"}
vec4( irradiance, 1 )
```

---
node: convolute_environment_spherical
input: { name:"Texture", type:"sampler2D" }
input: { name:"UV", type: "vec2" }
input: { name:"Size", type: "float", default: "0.5" }
input: { name:"Resolution", type: "int", default: "512" }
---

```{name:"Declaration", type:"text", restrict:"fshader", visible:false}
const float PI = 3.14159265359;
vec3 conv_environment( vec2 UV, float Size, int Resolution, sampler2D Texture ){
  float sampleDelta = max( 0.001, 1.0/ float( Resolution ));
  float nrSamples = 0.0;

  vec3 irradiance = vec3( 0.0 );
  float hsize = Size / 2;

  for ( float phi = -hsize; phi < hsize; phi += sampleDelta ){
    for ( float theta = -hsize; theta < hsize; theta += sampleDelta ){
      vec2 uv = vec2( UV.x + phi, 1-UV.y + theta );
      irradiance += texture2D( Texture, uv ).rgb * 4 * ( 0.25 - phi * theta );
      nrSamples++;
    }
  }
  irradiance = irradiance * ( 1.0 / float( nrSamples ));
  return irradiance;
}
```

```{name:"Initialization", type:"text", restrict:"fshader", visible:false}
  vec3 irradiance = conv_environment( $UV:assign$, $Size:assign$, $Resolution:assign$, $Texture:assign$ );
```

```{name:"Color", type:"color4", restrict:"assign"}
vec4( irradiance, 1 )
```

---
node: convolute_environment_spherical_mip
input: { name:"Texture", type:"sampler2D" }
input: { name:"UV", type: "vec2" }
input: { name:"Roughness", type: "float", default: "0.0" }
input: { name:"Resolution", type: "int", default: "128" }
---

```{name:"Declaration", type:"text", restrict:"fshader", visible: false}
// ----------------------------------------------------------------------------
float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    const float PI = 3.14159265359;
    float a = roughness*roughness;
    float a2 = a*a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;

    float nom   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return nom / denom;
}
// ----------------------------------------------------------------------------
// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
// efficient VanDerCorpus calculation.
float RadicalInverse_VdC(uint bits) 
{
     bits = (bits << 16u) | (bits >> 16u);
     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
     return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}
// ----------------------------------------------------------------------------
vec2 Hammersley(uint i, uint N)
{
	return vec2(float(i)/float(N), RadicalInverse_VdC(i));
}
// ----------------------------------------------------------------------------
vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)
{
  const float PI = 3.14159265359;
	float a = roughness*roughness;
	
	float phi = 2.0 * PI * Xi.x;
	float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
	float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
	
	// from spherical coordinates to cartesian coordinates - halfway vector
	vec3 H;
	H.x = cos(phi) * sinTheta;
	H.y = sin(phi) * sinTheta;
	H.z = cosTheta;
	
	// from tangent-space H vector to world-space sample vector
	vec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
	vec3 tangent   = normalize(cross(up, N));
	vec3 bitangent = cross(N, tangent);
	
	vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;
	return normalize(sampleVec);
}
// ----------------------------------------------------------------------------
vec3 conv_environment_mip( vec2 UV, sampler2D Texture, uint resolution, float roughness ){
  const float PI = 3.14159265359;
  //vec3 N = normalize(Normal);
  vec2 thetaphi= UV *
                 vec2( PI, -PI / 2 );
  vec3 R = normalize( vec3( 
                        cos( thetaphi.y ) * cos( thetaphi.x ),
                        sin( thetaphi.y ),
                        cos( thetaphi.y ) * sin( thetaphi.x )));

  
  // make the simplyfying assumption that V equals R equals the normal 
  vec3 N = R;
  vec3 V = R;

  const uint SAMPLE_COUNT = resolution;
  
  vec3 prefilteredColor = vec3( 0.0 );
  float totalWeight = 0.0;
  
  for( uint i = 0u; i < SAMPLE_COUNT; ++i )
  {
      // generates a sample vector that's biased towards the preferred alignment direction (importance sampling).
      vec2 Xi = Hammersley(i, SAMPLE_COUNT);
      vec3 H = ImportanceSampleGGX(Xi, N, roughness);
      vec3 L  = normalize(2.0 * dot(V, H) * H - V);
      
      const vec2 invAtan = vec2(0.1591, 0.3183);
      vec2 uv = vec2(atan(L.z, L.x), asin(L.y));
      uv *= invAtan;
      uv += 0.5;

      float NdotL = max(dot(N, L), 0.0);
      if(NdotL > 0.0)
      {
          // sample from the environment's mip level based on roughness/pdf
          float D   = DistributionGGX(N, H, roughness);
          float NdotH = max(dot(N, H), 0.0);
          float HdotV = max(dot(H, V), 0.0);
          float pdf = D * NdotH / (4.0 * HdotV) + 0.0001; 

          float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);
          float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);

          float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); 
          
          prefilteredColor += textureLod(Texture, uv, mipLevel).rgb * NdotL;
          totalWeight      += NdotL;
      }
  }
  prefilteredColor = prefilteredColor / totalWeight;
  //prefilteredColor = N;
  return prefilteredColor;
}
/*vec3N=R;
vec3V=R;
vec4r=vec4(0.0);
  
//Equirectangularenvironmentmapoutput
floatw=0.0;
for(inti=0;i<numSamples;i++){
vec3H=ImportanceSampleGGX(Hammersley(i,numSamples),uRoughness,N);
vec3L=-reflect(V,H);//((2.0*dot(V,H))*H)-V;
floatnDotL=clamp(dot(N,L),0.0,1.0);
if(nDotL>0.0){
r+=textureCube(iChannel0,L)*nDotL;
w+=nDotL;
}
}
gl_FragColor=r/max(w,1e-4)

  prefilteredColor = prefilteredColor / totalWeight;

  return prefilteredColor;
}*/
```

```{name:"Initialization", type:"text", restrict:"fshader", visible: false}
  vec3 irradiance = conv_environment_mip( $UV:assign$, $Texture:assign$, $Resolution:assign$, $Roughness:assign$ );
```

```{name:"Color", type:"color4", restrict:"assign"}
vec4( irradiance, 1 )
```

