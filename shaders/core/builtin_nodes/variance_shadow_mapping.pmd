---
node: variance_depth_write
---

```{name:"Declaration", type:"text", restrict:"fshader", visible: false}

// From http://fabiensanglard.net/shadowmappingVSM/index.php
vec4 get_moments(){
  float depth = vScreenPosition.z;// / vScreenPosition.w;
  depth = depth * 0.5 + 0.5;

  float moment1 = depth;
  float moment2 = depth * depth;

  float dx = dFdx(depth);
  float dy = dFdy(depth);
  moment2 += 0.25*(dx*dx+dy*dy);
  return vec4( moment1, moment2, 0.0, 1.0);
}
```

```{name:"Initialization", type:"text", restrict:"fshader", visible: false}
  vec4 variance_moments = get_moments();
```

```{name:"Depth", type:"vec4"}
variance_moments
```

---
node: variance_depth_test
input: { name: "LightSource", type: "int" }
---
#input: { name: "Map", type: "sampler2D" }

```{name:"Declaration", type:"text", restrict:"fshader", visible: false}

const int NUM_CASCADES = 4;

uniform mat4 LightMat$LightSource:assign$;//[ NUM_CASCADES ];
//uniform sampler2D LightMap$LightSource:assign$[ NUM_CASCADES ];
  
float chebyshevUpperBound( float Distance, vec2 UV, sampler2D Map )
{
  // We retrive the two moments previously stored (depth and depth*depth)
  vec2 moments0 = texture2D( Map, UV.xy ).rg;  
  vec2 moments1 = texture2D( Map, UV.xy, 1.5 ).rg;  
  vec2 moments2 = texture2D( Map, UV.xy, 2.5 ).rg;
  vec2 moments3 = texture2D( Map, UV.xy, 3.5 ).rg;
  vec2 moments = ( moments0 * 5 + moments1 + moments2 + moments3 ) / 8;
  //moments = moments0;
  
  // Surface is fully lit. as the current fragment is before the light occluder
  if ( Distance <= moments.x )
    return 1.0 ;

  // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check
  // How likely this pixel is to be lit (p_max)
  float variance = moments.y - (moments.x*moments.x);
  variance = max( variance, 0.00001 );  //was 0.00002

  float d = Distance - moments.x;
  float p_max = variance / ( variance + d*d );
  p_max = smoothstep( 0.2, 1.0, p_max );

  return p_max;
}
  
  
float shadow_test( vec4 shadow_coords, sampler2D Map ){
  vec3 ShadowCoordPostW = shadow_coords.xyz / shadow_coords.w;
  ShadowCoordPostW = clamp( ShadowCoordPostW * 0.5 + 0.5, 0, 1 ); //This is done via a bias matrix in main.c
  return 1-chebyshevUpperBound(ShadowCoordPostW.z, ShadowCoordPostW.xy, Map );
}

```

```{name:"Initialization", type:"text", restrict:"fshader", visible: false}
  //vec4 p = ( LightMat$LightSource:assign$ * vec4( vWorldPosition, 1 ));
  float variance_in_shadow$LightSource:assign$ = shadow_test( LightMat$LightSource:assign$/*[ i ]*/ * vec4( vWorldPosition, 1 ), LightMap$LightSource:assign$/*[ i ]*/);
```

```{name:"Shadow", type:"float", restrict:"fshader"}
variance_in_shadow
```
