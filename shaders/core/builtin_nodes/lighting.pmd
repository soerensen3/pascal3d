---
node: lib_light
---

```{name:"Library", type:"text", restrict:"fshader,declaration"}

#ifndef Lib_Light
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

const float PI = 3.14159265359;


#define saturate(a) clamp( a, 0.0, 1.0 )

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 worldposition;
  vec4 halfvector;
  vec4 direction;
  vec4 worlddirection;
  int type;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];
//uniform samplerCube IBLDiffuse;
//uniform samplerCube IBLSpecular;
uniform sampler2D IBLDiffuse;
uniform sampler2D IBLSpecular;
uniform sampler2D IBLIntegrateBRDF;
uniform float IBLFactor;

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;
}

float DistributionGGX(vec3 N, vec3 H, float a)
{
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
	
    float nom    = a2;
    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);
    denom        = PI * denom * denom;
	
    return nom / denom;
}

float GeometrySchlickGGX(float NdotV, float k)
{
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
	
    return nom / denom;
}
  
float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);
	
    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}   

vec3 BRDF_CookTorrance( in vec3 albedo, in float roughness, in float metallic, in vec3 normal, in vec3 lightDir ) {

  vec3 viewDir = -normalize( vCamPos - vWorldPosition );
  vec3 F0 = vec3( 0.04 ); 
  F0 = mix( F0, albedo, metallic );

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNH = saturate( dot( normal, halfDir ));
  float dotLH = max( 0, dot( lightDir, halfDir ));
  float dotNV = max( 0, dot( normal, viewDir ));
  float dotHV = max( 0, dot( halfDir, viewDir ));
  float dotNL = max( 0, dot( normal, lightDir ));

  vec3 F = fresnelSchlick( dotNV, F0 );//F_Schlick( F0, dotLH );

  float G = GeometrySmith( normal, viewDir, lightDir, roughness );

  float NDF = DistributionGGX( normal, halfDir, roughness );   
          
  vec3 nominator    = NDF * G * F; 
  float denominator = 4 * dotNV * dotNL + 0.001; // 0.001 to prevent divide by zero.
  vec3 specular = nominator / denominator;
  
  // kS is equal to Fresnel
  vec3 kS = F;
  // for energy conservation, the diffuse and specular light can't
  // be above 1.0 (unless the surface emits light); to preserve this
  // relationship the diffuse component (kD) should equal 1.0 - kS.
  vec3 kD = vec3( 1.0 ) - kS;
  // multiply kD by the inverse metalness such that only non-metals 
  // have diffuse lighting, or a linear blend if partly metal (pure metals
  // have no diffuse light).
  kD *= 1.0 - metallic;	  
  
  return max(( kD * albedo / PI + specular ) * dotNL, 0.0 );
}

float calculateAttenuation(in int i, in float dist, in float light_radius )
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
    return pow( clamp( 1 - pow( dist / light_radius, 4 ), 0, 1 ), 2 ) / ( pow( dist, 2) + 1 );
    //inverse square falloff
    
}

vec3 util_PointLightPBR( in int i, in vec3 albedo, in float roughness, in float metallic,                   
                         in vec3 N ){
    vec3 lVector = ( LightSource[ i ].worldposition.xyz - vWorldPosition.xyz );
    vec3 lightDir = normalize( lVector );  
    float attenuation = calculateAttenuation( i, length( lVector ), LightSource[i].linearAttenuation ); //pointLightDistance[ i ], pointLightDecay[ i ] );
       
    return BRDF_CookTorrance( albedo, roughness, metallic, N, lightDir ) * LightSource[ i ].color.rgb * LightSource[ i ].color.a;                    
}

vec3 util_directionalLightPBR( in int i, in vec3 albedo, in float roughness, in float metallic,                   
                               in vec3 N ){
    
    //float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));
    
    return BRDF_CookTorrance( albedo, roughness, metallic, N, LightSource[ i ].worlddirection.xyz ) * LightSource[ i ].color.rgb * LightSource[ i ].color.a;
}


void util_PointLight( in int i, in float shininess,
                      in vec3 N, inout vec3 diffuse, 
                      inout vec3 specular, in vec3 viewDir )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = calculateAttenuation( i, length( lVector ), LightSource[i].linearAttenuation ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );
    diffuse += ( LightSource[ i ].color.rgb ) * attenuation * LightSource[ i ].color.a * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * LightSource[ i ].color.a * cosineTerm;
}

void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular, 
                            in vec3 viewDir )
{
    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));
    diffuse += ( LightSource[ i ].color.rgb ) * LightSource[ i ].color.a * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( LightSource[ i ].color.rgb * LightSource[ i ].color.a, shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * cosineTerm;
}
#endif
#define Lib_Light
```
