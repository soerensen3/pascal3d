{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About What is Pascal3D Pascal3D (P3D) is an open source cross platform game engine for Free Pascal/Lazarus. It is focussed on ease of use while trying to be flexible enough to support advanced features and being extendable. Features Object oriented Game data is organized in data blocks similar to Blender Saving and loading Blender export script (Python) Garbage collector Scenes that can be rendered separately Instancing Properties are streamed from/to file automatically Materials Custom Shader Materials with GLSL (very basic) Node Based Materials You can define your own nodes in P3D Markdown with GLSL PBR and Blinn/Phong nodes Image based lightning - can be generated from environment maps on the fly Simple ocean shader Graphical User Interface A GUI similar to Lazarus' LCL Form editor for visually designing your interface (Planned) Prerendered bitmap texts and SDF fonts Signed distance field for Bitmap Fonts TTF fonts can be easily converted to Bitmap Fonts Editor library for creating an IDE to edit p3d files Works with OpenGL 2.1+ (Some functions like PBR need OpenGL 3.3) Pascal3D License Pascal3D is published under the MIT License The MIT License (MIT) Copyright (c) 2019 Johannes Rosleff Soerensen Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"About"},{"location":"#about","text":"","title":"About"},{"location":"#what-is-pascal3d","text":"Pascal3D (P3D) is an open source cross platform game engine for Free Pascal/Lazarus. It is focussed on ease of use while trying to be flexible enough to support advanced features and being extendable.","title":"What is Pascal3D"},{"location":"#features","text":"Object oriented Game data is organized in data blocks similar to Blender Saving and loading Blender export script (Python) Garbage collector Scenes that can be rendered separately Instancing Properties are streamed from/to file automatically Materials Custom Shader Materials with GLSL (very basic) Node Based Materials You can define your own nodes in P3D Markdown with GLSL PBR and Blinn/Phong nodes Image based lightning - can be generated from environment maps on the fly Simple ocean shader Graphical User Interface A GUI similar to Lazarus' LCL Form editor for visually designing your interface (Planned) Prerendered bitmap texts and SDF fonts Signed distance field for Bitmap Fonts TTF fonts can be easily converted to Bitmap Fonts Editor library for creating an IDE to edit p3d files Works with OpenGL 2.1+ (Some functions like PBR need OpenGL 3.3)","title":"Features"},{"location":"#pascal3d-license","text":"Pascal3D is published under the MIT License","title":"Pascal3D License"},{"location":"#the-mit-license-mit","text":"Copyright (c) 2019 Johannes Rosleff Soerensen Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"getting-started/","text":"Getting started Supported platforms Officially supported are Linux and Windows. In theory it should also work on OSX but I couldn't verify this yet. It should also be possible to use the engine on mobile devices such as Android in the future but currently the code is not OpenGL ES compatible. There won't be a web target anytime soon because it would require too many changes in the code base. Download For cloning the repository you need the git utility. For installation instructions refer to https://git-scm.com/. Assuming you have installed git you can clone the repository using the following command: git clone https://github.com/soerensen3/pascal3d.git Info Alternatively, if you do not want to install git, you can follow the link , use the Clone or download button and download as zip file. Dependencies SDL2 Pascal3D uses SDL2, which is an open source cross platform media library. It offers low level access \"to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL\". You can get SDL2 from the repositories (Linux) or from here (Windows, OSX): SDL2 SDL2_image SDL2_ttf Linux Install sdl2, sdl2-ttf, sdl2-image including developer version in some distros (Fedora, Ubuntu, ...) using your package manager. Windows Download the files from above and copy them to the system32 folder or to the target folder of each application you want to compile. OSX Download the files from above and install the dmg files. Lazarus Lazarus is a cross platform RAD-IDE for Free Pascal. If you do not know Lazarus/Free Pascal you should probably start reading about it first. You can download Lazarus from Lazarus Official Website or ( Linux ) from the repositories of your distro. These websites offer a simplified installer suitable for all platforms: fpcupdeluxe and getlazarus . Pascal3D Math For Pascal3D you need the pascal3d_math library which is an extra repository. Simply go to the directory of your choice and execute this command or download as zip following the link . git clone https://github.com/soerensen3/math3d.git dglOpenGL and SDL2 Headers Pascal3D comes with dglOpenGL because the original version did not have a package. Apart from that the files are unchanged. You can download the original version from here . The same applies to the SDL2 Headers by Tim Blume which are downloadable from here . Building from source Register the packages Before you can compile any Pascal3D you have to first register the packages in Lazarus. You can do this by opening the packages in the IDE. You need to open the following packages: <pascal3d_math package> ./external/dglopengl/pl_opengl.lpk ./external/libsdl2/libsdl2.lpk ./src/pascal3d.lpk ./src/p3dgui/pascal3d_gui.lpk Compiling The easiest way is to open the project in Lazarus and compile there. You can however also compile from commandline using lazbuild. You will find the project for the official p3dscene editor in ./editor/p3dscene.lpi Todo A lot of bugfixing - Making pascal3d more stable Add shadow maps Add octrees","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#supported-platforms","text":"Officially supported are Linux and Windows. In theory it should also work on OSX but I couldn't verify this yet. It should also be possible to use the engine on mobile devices such as Android in the future but currently the code is not OpenGL ES compatible. There won't be a web target anytime soon because it would require too many changes in the code base.","title":"Supported platforms"},{"location":"getting-started/#download","text":"For cloning the repository you need the git utility. For installation instructions refer to https://git-scm.com/. Assuming you have installed git you can clone the repository using the following command: git clone https://github.com/soerensen3/pascal3d.git Info Alternatively, if you do not want to install git, you can follow the link , use the Clone or download button and download as zip file.","title":"Download"},{"location":"getting-started/#dependencies","text":"","title":"Dependencies"},{"location":"getting-started/#sdl2","text":"Pascal3D uses SDL2, which is an open source cross platform media library. It offers low level access \"to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL\". You can get SDL2 from the repositories (Linux) or from here (Windows, OSX): SDL2 SDL2_image SDL2_ttf","title":"SDL2"},{"location":"getting-started/#linux","text":"Install sdl2, sdl2-ttf, sdl2-image including developer version in some distros (Fedora, Ubuntu, ...) using your package manager.","title":"Linux"},{"location":"getting-started/#windows","text":"Download the files from above and copy them to the system32 folder or to the target folder of each application you want to compile.","title":"Windows"},{"location":"getting-started/#osx","text":"Download the files from above and install the dmg files.","title":"OSX"},{"location":"getting-started/#lazarus","text":"Lazarus is a cross platform RAD-IDE for Free Pascal. If you do not know Lazarus/Free Pascal you should probably start reading about it first. You can download Lazarus from Lazarus Official Website or ( Linux ) from the repositories of your distro. These websites offer a simplified installer suitable for all platforms: fpcupdeluxe and getlazarus .","title":"Lazarus"},{"location":"getting-started/#pascal3d-math","text":"For Pascal3D you need the pascal3d_math library which is an extra repository. Simply go to the directory of your choice and execute this command or download as zip following the link . git clone https://github.com/soerensen3/math3d.git","title":"Pascal3D Math"},{"location":"getting-started/#dglopengl-and-sdl2-headers","text":"Pascal3D comes with dglOpenGL because the original version did not have a package. Apart from that the files are unchanged. You can download the original version from here . The same applies to the SDL2 Headers by Tim Blume which are downloadable from here .","title":"dglOpenGL and SDL2 Headers"},{"location":"getting-started/#building-from-source","text":"","title":"Building from source"},{"location":"getting-started/#register-the-packages","text":"Before you can compile any Pascal3D you have to first register the packages in Lazarus. You can do this by opening the packages in the IDE. You need to open the following packages: <pascal3d_math package> ./external/dglopengl/pl_opengl.lpk ./external/libsdl2/libsdl2.lpk ./src/pascal3d.lpk ./src/p3dgui/pascal3d_gui.lpk","title":"Register the packages"},{"location":"getting-started/#compiling","text":"The easiest way is to open the project in Lazarus and compile there. You can however also compile from commandline using lazbuild. You will find the project for the official p3dscene editor in ./editor/p3dscene.lpi Todo A lot of bugfixing - Making pascal3d more stable Add shadow maps Add octrees","title":"Compiling"},{"location":"reference/overview/","text":"Overview Pascal3D is organized in several components that are provided with different packages. Package Unit Description pascal3d_math p3d.math Math unit that provides classes and functions for vectors, matrices and quaternions pascal3d_core p3d.utils Basic utils, list classes and file streaming for properties p3d.events Application class, Creation of windows input handling and a logger p3d.plot Advanced plotting library that is easy to use pascal3d_base p3d.base Enhancement of p3dplot and classes for meshs, cameras, lights, etc. pascal3d_ui p3d.ui Graphical user interface with basic classes for windows, buttons, etc. pascal3d_ide p3d.ide UI classes used by P3DScene editor that can also be used for in game debugging Core and base packages The core package is pascal3d_core that provides the basic functionality as well as p3dplot . You may want to start here to get started with Pascal3D. The other packages offer extra functionality and are optional. The package pascal3d_base will supply the basic structures as that greatly simplify working with game data and loading them from files or saving them. Among these are meshes, materials, lights as well as a scene graph to display them. UI packages If you need a UI have a look at the package pascal3d_ui . It provides an advanced graphical user interface that is inspired by the Lazarus LCL . Different kind of components are at stake and if needed it is also possible to define your own by deriving from a the base class TP3DGraphicControl or extend any of the already defined components. Finally there is the pascal3d_ide package that is used by the P3DScene editor. This editor allows editing the game data such as scenes or materials in a comfortable WYSIWYG way. However the package can also useful for debugging your game data. All of the editors can be used inside your project an make it possible to debug and edit all of your game data at runtime. This can greatly reduce development time.","title":"Overview"},{"location":"reference/overview/#overview","text":"Pascal3D is organized in several components that are provided with different packages. Package Unit Description pascal3d_math p3d.math Math unit that provides classes and functions for vectors, matrices and quaternions pascal3d_core p3d.utils Basic utils, list classes and file streaming for properties p3d.events Application class, Creation of windows input handling and a logger p3d.plot Advanced plotting library that is easy to use pascal3d_base p3d.base Enhancement of p3dplot and classes for meshs, cameras, lights, etc. pascal3d_ui p3d.ui Graphical user interface with basic classes for windows, buttons, etc. pascal3d_ide p3d.ide UI classes used by P3DScene editor that can also be used for in game debugging","title":"Overview"},{"location":"reference/overview/#core-and-base-packages","text":"The core package is pascal3d_core that provides the basic functionality as well as p3dplot . You may want to start here to get started with Pascal3D. The other packages offer extra functionality and are optional. The package pascal3d_base will supply the basic structures as that greatly simplify working with game data and loading them from files or saving them. Among these are meshes, materials, lights as well as a scene graph to display them.","title":"Core and base packages"},{"location":"reference/overview/#ui-packages","text":"If you need a UI have a look at the package pascal3d_ui . It provides an advanced graphical user interface that is inspired by the Lazarus LCL . Different kind of components are at stake and if needed it is also possible to define your own by deriving from a the base class TP3DGraphicControl or extend any of the already defined components. Finally there is the pascal3d_ide package that is used by the P3DScene editor. This editor allows editing the game data such as scenes or materials in a comfortable WYSIWYG way. However the package can also useful for debugging your game data. All of the editors can be used inside your project an make it possible to debug and edit all of your game data at runtime. This can greatly reduce development time.","title":"UI packages"},{"location":"reference/pascal3d_base_overview/","text":"pascal3d_base This package extends p3d.plot with a scene graph and basic structures like meshes, materials or lights. Different types of data blocks A Pascal3D library is organized in data blocks similar to Blender. These comprise meshes, materials, lights or scenes and belong to exactly one entity called a library. This library contains slots for all different kind of data blocks. Scene graph and objects While these data blocks can be used on their own these are typically used with scenes. A scene contains one ore more objects. The Data property determines the nature of the object (A mesh, camera or lamp) and is a link to another data block in the same library or another library. The Transform property holds information about location, rotation and scale of the object. This way the spatial representation in the scene is separated from the actual data and makes it possible to reuse eg. meshes without making a copy of them and take up more space in memory (Instancing). While the different kind of data can be used by many objects each object should be used by exactly one scene only. It is however possible to set the data property to reference other scenes and move them in space. For example the world can be a scene and the player can be another scene that moves in the first scene. Objects can have one or more child objects that are transformed together with their parent object. Saving and loading game data A Pascal3D library can be saved to or loaded from a json file (.p3d). This file is meant to be human readable to make it possible to get a quick overview and to be able to make minor adjustments. As some structures as meshes contain a high amount of data and thus reduce the readibility their data is stored in an extra binary with the same name but with a different extension (.p3dbin). This also lowers file size and loading time. The file is referenced to with an offset by the json file and is useless without it, so whatever you change in the json file, do not edit this information unless you know what you are doing. While you can make manual changes to the files in most cases you may want to use the P3DScene editor or use the Blender exporter script to generate or modify them.","title":"pascal3d_base"},{"location":"reference/pascal3d_base_overview/#pascal3d_base","text":"This package extends p3d.plot with a scene graph and basic structures like meshes, materials or lights.","title":"pascal3d_base"},{"location":"reference/pascal3d_base_overview/#different-types-of-data-blocks","text":"A Pascal3D library is organized in data blocks similar to Blender. These comprise meshes, materials, lights or scenes and belong to exactly one entity called a library. This library contains slots for all different kind of data blocks.","title":"Different types of data blocks"},{"location":"reference/pascal3d_base_overview/#scene-graph-and-objects","text":"While these data blocks can be used on their own these are typically used with scenes. A scene contains one ore more objects. The Data property determines the nature of the object (A mesh, camera or lamp) and is a link to another data block in the same library or another library. The Transform property holds information about location, rotation and scale of the object. This way the spatial representation in the scene is separated from the actual data and makes it possible to reuse eg. meshes without making a copy of them and take up more space in memory (Instancing). While the different kind of data can be used by many objects each object should be used by exactly one scene only. It is however possible to set the data property to reference other scenes and move them in space. For example the world can be a scene and the player can be another scene that moves in the first scene. Objects can have one or more child objects that are transformed together with their parent object.","title":"Scene graph and objects"},{"location":"reference/pascal3d_base_overview/#saving-and-loading-game-data","text":"A Pascal3D library can be saved to or loaded from a json file (.p3d). This file is meant to be human readable to make it possible to get a quick overview and to be able to make minor adjustments. As some structures as meshes contain a high amount of data and thus reduce the readibility their data is stored in an extra binary with the same name but with a different extension (.p3dbin). This also lowers file size and loading time. The file is referenced to with an offset by the json file and is useless without it, so whatever you change in the json file, do not edit this information unless you know what you are doing. While you can make manual changes to the files in most cases you may want to use the P3DScene editor or use the Blender exporter script to generate or modify them.","title":"Saving and loading game data"},{"location":"reference/pascal3d_overview/","text":"pascal3d_core This is the core package of Pascal3D. It is organized in three units. Creating an application and handle events and inputs The unit pascal3d.events provides the TP3DApplication class that you can derive your project from and that handles all communication with the OS. Here you can also create your window with an OpenGL context where all the rendering takes place. This window also defines methods for the interaction with the user. Input devices (Keyboard, Mouse, Gamepad/Joystick) can be queried here. Rendering The unit pascal3d.core comprises all the render related structures. Utility functions. The unit pascal3d.utils is used by all the other units and provides basic structures such as templates for various types of lists or the powerful streaming system that automates writing and reading of classes to/from json or binary files. You normally don't need to use this unit directly.","title":"pascal3d_core"},{"location":"reference/pascal3d_overview/#pascal3d_core","text":"This is the core package of Pascal3D. It is organized in three units.","title":"pascal3d_core"},{"location":"reference/pascal3d_overview/#creating-an-application-and-handle-events-and-inputs","text":"The unit pascal3d.events provides the TP3DApplication class that you can derive your project from and that handles all communication with the OS. Here you can also create your window with an OpenGL context where all the rendering takes place. This window also defines methods for the interaction with the user. Input devices (Keyboard, Mouse, Gamepad/Joystick) can be queried here.","title":"Creating an application and handle events and inputs"},{"location":"reference/pascal3d_overview/#rendering","text":"The unit pascal3d.core comprises all the render related structures.","title":"Rendering"},{"location":"reference/pascal3d_overview/#utility-functions","text":"The unit pascal3d.utils is used by all the other units and provides basic structures such as templates for various types of lists or the powerful streaming system that automates writing and reading of classes to/from json or binary files. You normally don't need to use this unit directly.","title":"Utility functions."},{"location":"tutorials/01-first-project/","text":"Your first project In this tutorial we will set up a basic application that creates a blank window and terminates when the close button of the window is pressed. This can be considered the minimal application for using Pascal3D. It is assumed that you have basic knowledge of Lazarus and Free Pascal. Preparing the project and main unit As a base we create a new empty project by clicking File->New->Simple Program. We then add a new unit to the program and add the following units to the uses clause of the main unit. We don't necessarily need an extra unit but it facilates clarity of the code. Hint Don't forget to add the pascal3d package to the dependencies of your project in the Lazarus project inspector. unit MainUnit ; {$mode objfpc}{$H+} interface uses Classes , SysUtils , p3d . events , p3d . core ; ... Next we need to define our application class. We therefore inherit our class from TP3DApplication. For now it is just the empty class but in another step we are going to change this. ... type { TMyApplication } TMyApplication = class ( TP3DApplication ) end ; var MyApplication : TMyApplication = nil ; ... In our main program we create our instance of our defined application. It will also set the global variable P3DApplication in p3d.events that is used by the p3d units. In the loaded units are some other global variables that need to be initialized before you can use them. This is automatically done when creating the application, so this should usually be the first step. With a call of Run we enter the main loop that is executed until a quit event is triggered by the user or the OS. Finally after the application has terminated we are freeing it. If we execute the program now it starts up and quickly terminates. That is because we do not have a main window. program CreateWindow ; uses MainUnit , SysUtils ; begin MyApplication := TMyApplication . Create () ; MyApplication . Run ; FreeAndNil ( MyApplication ) ; end . Creating the window So before running the app we need to create a main window. This can be done by the following line. The MyApplication.Windows parameter determines the owner of the Window. This owner will automatically free the window when the application object is destroyed. MyApplication.Windows should hold all windows used in our application. It is possible to have more than one window. The main window is the first window created and if that is set to nil (e.g. because it is destroyed) the application will exit the main loop. TP3DWindow . Create ( MyApplication . Windows ) ; For the sake of cleanliness of the code we put this in a separate init procedure and not in the main program. TP3DApplication provides various hooks for interaction with the application (e.g. initialization, finalization, input). For that purpose we override the Initialize method in our application class. This is where all the steps necessary to prepare the application before running it should go (eg. creation of a window or loading of assets). We do not need to call this function manually because it is automatically called after creating the application. We can change the title and the resolution of the window as shown in the code below. It is also possible to switch to full screen mode. unit MainUnit ; {$mode objfpc}{$H+} interface uses Classes , SysUtils , p3d . events , p3d . core ; type { TMyApplication } TMyApplication = class ( TP3DApplication ) public procedure Initialize ; override ; // Override the Initialize procedure // for initialization of your window // and all your assets end ; var MyApplication : TMyApplication = nil ; implementation { TMyApplication } procedure TMyApplication . Initialize ; begin inherited Initialize ; TP3DWindow . Create ( Windows ) ; // Create the main window. Note that // this is freed automatically when // the application terminates MainWindow . Title := 'My first Pascal3D application' ; // Set the title MainWindow . Width := 800 ; // Set the resolution MainWindow . Height := 600 ; // Uncomment if you want full screen mode // Exit the application with Alt + F4 / Command + Q //MainWindow.FullScreen:= True; end ; Now if we run the code only a blank window is shown. If it is closed the application terminates. In the next tutorials we are going to extend this.","title":"Your first project"},{"location":"tutorials/01-first-project/#your-first-project","text":"In this tutorial we will set up a basic application that creates a blank window and terminates when the close button of the window is pressed. This can be considered the minimal application for using Pascal3D. It is assumed that you have basic knowledge of Lazarus and Free Pascal.","title":"Your first project"},{"location":"tutorials/01-first-project/#preparing-the-project-and-main-unit","text":"As a base we create a new empty project by clicking File->New->Simple Program. We then add a new unit to the program and add the following units to the uses clause of the main unit. We don't necessarily need an extra unit but it facilates clarity of the code. Hint Don't forget to add the pascal3d package to the dependencies of your project in the Lazarus project inspector. unit MainUnit ; {$mode objfpc}{$H+} interface uses Classes , SysUtils , p3d . events , p3d . core ; ... Next we need to define our application class. We therefore inherit our class from TP3DApplication. For now it is just the empty class but in another step we are going to change this. ... type { TMyApplication } TMyApplication = class ( TP3DApplication ) end ; var MyApplication : TMyApplication = nil ; ... In our main program we create our instance of our defined application. It will also set the global variable P3DApplication in p3d.events that is used by the p3d units. In the loaded units are some other global variables that need to be initialized before you can use them. This is automatically done when creating the application, so this should usually be the first step. With a call of Run we enter the main loop that is executed until a quit event is triggered by the user or the OS. Finally after the application has terminated we are freeing it. If we execute the program now it starts up and quickly terminates. That is because we do not have a main window. program CreateWindow ; uses MainUnit , SysUtils ; begin MyApplication := TMyApplication . Create () ; MyApplication . Run ; FreeAndNil ( MyApplication ) ; end .","title":"Preparing the project and main unit"},{"location":"tutorials/01-first-project/#creating-the-window","text":"So before running the app we need to create a main window. This can be done by the following line. The MyApplication.Windows parameter determines the owner of the Window. This owner will automatically free the window when the application object is destroyed. MyApplication.Windows should hold all windows used in our application. It is possible to have more than one window. The main window is the first window created and if that is set to nil (e.g. because it is destroyed) the application will exit the main loop. TP3DWindow . Create ( MyApplication . Windows ) ; For the sake of cleanliness of the code we put this in a separate init procedure and not in the main program. TP3DApplication provides various hooks for interaction with the application (e.g. initialization, finalization, input). For that purpose we override the Initialize method in our application class. This is where all the steps necessary to prepare the application before running it should go (eg. creation of a window or loading of assets). We do not need to call this function manually because it is automatically called after creating the application. We can change the title and the resolution of the window as shown in the code below. It is also possible to switch to full screen mode. unit MainUnit ; {$mode objfpc}{$H+} interface uses Classes , SysUtils , p3d . events , p3d . core ; type { TMyApplication } TMyApplication = class ( TP3DApplication ) public procedure Initialize ; override ; // Override the Initialize procedure // for initialization of your window // and all your assets end ; var MyApplication : TMyApplication = nil ; implementation { TMyApplication } procedure TMyApplication . Initialize ; begin inherited Initialize ; TP3DWindow . Create ( Windows ) ; // Create the main window. Note that // this is freed automatically when // the application terminates MainWindow . Title := 'My first Pascal3D application' ; // Set the title MainWindow . Width := 800 ; // Set the resolution MainWindow . Height := 600 ; // Uncomment if you want full screen mode // Exit the application with Alt + F4 / Command + Q //MainWindow.FullScreen:= True; end ; Now if we run the code only a blank window is shown. If it is closed the application terminates. In the next tutorials we are going to extend this.","title":"Creating the window"},{"location":"tutorials/02-first-triangle/","text":"Rendering a triangle The most prominent example for OpenGL is probably that of rendering a colored triangle. This tutorial shows how this is done using Pascal3D. Though nothing keeps you from using OpenGL directly Pascal3D provides a powerful API that greatly simplifies rendering. Many basic OpenGL tutorials use the so called immediate mode because it is very simple to use. This has however been deprecated in OpenGL 3.x in favor of buffer objects because of it's poor performance and for compatibility reasons. While being more efficient it is a harder to understand for a beginner. The P3DPlot library (in p3d.core) aims for simplicity while at the same time using buffer objects. A short introduction to graphic functions of Pascal3D Rendering a red triangle is described through the following command. geom_polygon ([ vec3 ( - 1 ,- 1 , 0 ) , vec3 ( 1 , - 1 , 0 ) , vec3 ( 0 , 1 , 0 )] , settings ([ attrib ( P3DAttribColor , vec4 ( 1 , 0 , 0 , 1 )) // Red ]) The name of the function determines what type of geometry we want to draw (geom_points, geom_lines, geom_polygon). The first parameter is an array of coordinates and determines where we want to draw. The lower left corner is at -1,-1,0 and the upper right is at 1, 1. The coordinates have three dimensions but for now we can ignore the last coordinate. We use the vec3 constructor for a three dimensional vector defined in p3d.math which syntax is similar to that of GLSL . P3DPlot distinguishes between two types of commands, layers and settings. The former represents a drawing operation while the latter determines how it is performed. With the second parameter is of type setting. We can pass our attributes and uniforms there. It is possible to pass more than one setting which is why we need to enclose them in a settings block. This will turn an array of settings into a list class that can be used for rendering. With attrib we say we want to pass an attribute. The location parameter is set to the color attribute and the color is passed as a four dimensional vector (the components correspond to the channels Red, Green, Blue, Alpha). So vec4( 1, 0, 0, 1 ) is red with an alpha value of 1. This results in the whole triangle becoming red. It is also possible to define one color for each vertex. attrib ( P3DAttribColor , [ vec4 ( 1 , 0 , 0 , 1 ) , vec4 ( 0 , 1 , 0 , 1 ) , vec4 ( 0 , 0 , 1 , 1 )]) Hint If we pass nil the color attribute will remain undefined. This sometimes makes sense but when using geom_points/geom_lines/geom_polygon you should always define a color because otherwise the color of the triangle will depend on what the attribute was previously set to or even on the OpenGL implementation. E.g. the triangle will by default be black on Intel and white on NVidia hardware. For efficiency the polygon is not rendered directly. A call to the geometry functions will create a list of function calls that can be executed later. We therefore store the this list in a variable so this list has to be generated only once. Similar to the settings it is possible to store more than one function call in the list. We might want to clear the color buffer before rendering our triangle with command_clear first. We therefore have to pass a list of the function calls to the layers function to make a plot list that can be rendered later. The complete function call will then be: TriangleList := layers ([ command_clear ([ cfColor , cfDepth ] , vec4 ( 0.5 , 0.5 , 0.5 , 1 )) , // Clear the background and depth buffer with grey geom_polygon ([ vec3 ( - 1 ,- 1 , 0 ) , vec3 ( 1 , - 1 , 0 ) , vec3 ( 0 , 1 , 0 )] , // draws a triangle from the passed coordinates settings ([ attrib ( P3DAttribColor , [ vec4 ( 1 , 0 , 0 , 1 ) , vec4 ( 0 , 1 , 0 , 1 ) , vec4 ( 0 , 0 , 1 , 1 )]) // sets the color attribute for each vertex ]) ) ]) ; And for rendering we call the Execute method. TriangleList . Execute ; Preparing the app for the rendering We start with the project from the last tutorial. To store our render calls we add a field FTriangleList of type TP3DPlotListLayer. Since we it is not freed automatically we override the Finalize method. The render method is called from the application's main loop. This is where we execute our triangle list. To generate the list we make a SetupTriangle method that is called from initialize. TMyApplication = class ( TP3DApplication ) private FTriangleList : TP3DPlotListLayer ; public procedure Initialize ; override ; // Override the initialize procedure to // allow custom initializations procedure Finalize ; override ; procedure Render ; override ; procedure SetupTriangle ; end ; Hint Since P3DPlot relies on shader nodes we need to define where our shaders are located. This is in the pascal3d/shaders/ directory. For your own projects you may want to copy these files to your project directory. procedure TMyApplication . Initialize ; begin inherited Initialize ; TP3DWindow . Create ( Windows ) ; // Create the main window. Note that this is freed // automatically when the application terminates MainWindow . Title := 'Rendering a triangle' ; // Set the title P3DShaderNodeLib . LoadLibraryPath ( '../../../shaders/' ) ; SetupTriangle ; end ; procedure TMyApplication . Finalize ; begin FreeAndNil ( FTriangleList ) ; // Free the triangle list inherited Finalize ; end ; The Render method that is executed on each frame is very simple. We just execute our triangle list. procedure TMyApplication . Render ; begin inherited Render ; FTriangleList . Execute ; end ;","title":"Rendering a triangle"},{"location":"tutorials/02-first-triangle/#rendering-a-triangle","text":"The most prominent example for OpenGL is probably that of rendering a colored triangle. This tutorial shows how this is done using Pascal3D. Though nothing keeps you from using OpenGL directly Pascal3D provides a powerful API that greatly simplifies rendering. Many basic OpenGL tutorials use the so called immediate mode because it is very simple to use. This has however been deprecated in OpenGL 3.x in favor of buffer objects because of it's poor performance and for compatibility reasons. While being more efficient it is a harder to understand for a beginner. The P3DPlot library (in p3d.core) aims for simplicity while at the same time using buffer objects.","title":"Rendering a triangle"},{"location":"tutorials/02-first-triangle/#a-short-introduction-to-graphic-functions-of-pascal3d","text":"Rendering a red triangle is described through the following command. geom_polygon ([ vec3 ( - 1 ,- 1 , 0 ) , vec3 ( 1 , - 1 , 0 ) , vec3 ( 0 , 1 , 0 )] , settings ([ attrib ( P3DAttribColor , vec4 ( 1 , 0 , 0 , 1 )) // Red ]) The name of the function determines what type of geometry we want to draw (geom_points, geom_lines, geom_polygon). The first parameter is an array of coordinates and determines where we want to draw. The lower left corner is at -1,-1,0 and the upper right is at 1, 1. The coordinates have three dimensions but for now we can ignore the last coordinate. We use the vec3 constructor for a three dimensional vector defined in p3d.math which syntax is similar to that of GLSL . P3DPlot distinguishes between two types of commands, layers and settings. The former represents a drawing operation while the latter determines how it is performed. With the second parameter is of type setting. We can pass our attributes and uniforms there. It is possible to pass more than one setting which is why we need to enclose them in a settings block. This will turn an array of settings into a list class that can be used for rendering. With attrib we say we want to pass an attribute. The location parameter is set to the color attribute and the color is passed as a four dimensional vector (the components correspond to the channels Red, Green, Blue, Alpha). So vec4( 1, 0, 0, 1 ) is red with an alpha value of 1. This results in the whole triangle becoming red. It is also possible to define one color for each vertex. attrib ( P3DAttribColor , [ vec4 ( 1 , 0 , 0 , 1 ) , vec4 ( 0 , 1 , 0 , 1 ) , vec4 ( 0 , 0 , 1 , 1 )]) Hint If we pass nil the color attribute will remain undefined. This sometimes makes sense but when using geom_points/geom_lines/geom_polygon you should always define a color because otherwise the color of the triangle will depend on what the attribute was previously set to or even on the OpenGL implementation. E.g. the triangle will by default be black on Intel and white on NVidia hardware. For efficiency the polygon is not rendered directly. A call to the geometry functions will create a list of function calls that can be executed later. We therefore store the this list in a variable so this list has to be generated only once. Similar to the settings it is possible to store more than one function call in the list. We might want to clear the color buffer before rendering our triangle with command_clear first. We therefore have to pass a list of the function calls to the layers function to make a plot list that can be rendered later. The complete function call will then be: TriangleList := layers ([ command_clear ([ cfColor , cfDepth ] , vec4 ( 0.5 , 0.5 , 0.5 , 1 )) , // Clear the background and depth buffer with grey geom_polygon ([ vec3 ( - 1 ,- 1 , 0 ) , vec3 ( 1 , - 1 , 0 ) , vec3 ( 0 , 1 , 0 )] , // draws a triangle from the passed coordinates settings ([ attrib ( P3DAttribColor , [ vec4 ( 1 , 0 , 0 , 1 ) , vec4 ( 0 , 1 , 0 , 1 ) , vec4 ( 0 , 0 , 1 , 1 )]) // sets the color attribute for each vertex ]) ) ]) ; And for rendering we call the Execute method. TriangleList . Execute ;","title":"A short introduction to graphic functions of Pascal3D"},{"location":"tutorials/02-first-triangle/#preparing-the-app-for-the-rendering","text":"We start with the project from the last tutorial. To store our render calls we add a field FTriangleList of type TP3DPlotListLayer. Since we it is not freed automatically we override the Finalize method. The render method is called from the application's main loop. This is where we execute our triangle list. To generate the list we make a SetupTriangle method that is called from initialize. TMyApplication = class ( TP3DApplication ) private FTriangleList : TP3DPlotListLayer ; public procedure Initialize ; override ; // Override the initialize procedure to // allow custom initializations procedure Finalize ; override ; procedure Render ; override ; procedure SetupTriangle ; end ; Hint Since P3DPlot relies on shader nodes we need to define where our shaders are located. This is in the pascal3d/shaders/ directory. For your own projects you may want to copy these files to your project directory. procedure TMyApplication . Initialize ; begin inherited Initialize ; TP3DWindow . Create ( Windows ) ; // Create the main window. Note that this is freed // automatically when the application terminates MainWindow . Title := 'Rendering a triangle' ; // Set the title P3DShaderNodeLib . LoadLibraryPath ( '../../../shaders/' ) ; SetupTriangle ; end ; procedure TMyApplication . Finalize ; begin FreeAndNil ( FTriangleList ) ; // Free the triangle list inherited Finalize ; end ; The Render method that is executed on each frame is very simple. We just execute our triangle list. procedure TMyApplication . Render ; begin inherited Render ; FTriangleList . Execute ; end ;","title":"Preparing the app for the rendering"},{"location":"tutorials/03-rotation-and-dynamic-data/","text":"Rotating the triangle and dynamic data In the last example we learned how to render a static scene with a triangle. We will start with that and implement a rotation. Subsequently you will learn how to render dynamic data. The transform class For describing the rotation a matrix is used. For a general introduction on vectors, matrices and transforms I can recommend this tutorial . For Pascal3D you do not necessarily understand how matrices are composed, though it helps. In Pascal3D a transform can be described with the TP3DTransform class. It is a frontend for all the common transformations (Translation, rotation, scale) which are then assembled to a matrix. In 3D math rotations can be described by matrices, euler angles or by quaternions (There are even more methods). TP3DTransform = class ( TP3DStreamable ) ... // Common translations --> property Position : TVec3 ; // Translation for moving the scene property Scale : TVec3 ; // Scaling the scene along the global axes // for rotation use property Rotation : TVec3 ; // Rotation with euler angles around the global axes (XYZ) // or property Quaternion : TQuat ; // Rotation in quaternion style (useful for bones, not prone to gimbal lock) // the other is then updated automatically // <-- Common translations property Direction : TVec3 ; // Where is the transformed object pointing (useful for cameras or lights) [readonly] property Matrix : TMat4 ; // Matrix that contains all the above transforms property MatrixInv : TMat4 ; // Inverse matrix to undo the transformation property RotationOrder : TRotationOrder ; // Determines in which order the transforms are applied end ; The above listing shows the important properties of a TP3DTransform object in pseudo code. You can edit any of these and the others are automatically updated if necessary. Use the Position property if you want to shift the scene, the Scale property to for applying a scale and one of the two rotation types ( Rotation or Quaternion ) to rotate the scene. You can also set the Matrix property if you prefer to. The transformations are typically distinguished between World , View and Projection . In the former the scene is transformed, in the second the camera. The difference is that to get the same visual results a View transform has to be opposite or inverse of the world transform. A camera that moves to the right, for example, causes the scene to shift optically to the left. The Projection transform decides how the three-dimensional scene is displayed on the screen. This can be either orthogonal or perspective. Finally there is the RotationOrder . This determines which transformation is applied first. First moving a scene and then rotating it results in a different effect than the other way round. Transforming the triangle In this tutorial we use a world transform to rotate the triangle itself. Extending the code from the previous tutorial we can pass our World: TP3DTransform object in the settings of our triangle. However we first have to create our World transform object. TMyApplication = class ( TP3DApplication ) private FWorld : TP3DTransform ; ... public ... property World : TP3DTransform read FWorld ; end ; And in our Initialize method we have to create the object on initialization. We create a P3D property that is the owner of the World object. We don't need to free it ourselves then as this is done automatically when the program terminates. procedure TMyApplication . Initialize ; var Prop : TP3DStreamableContainer ; // Use a local variable for the property as we do not need to keep track of it begin ... Prop := TP3DStreamableContainer . Create ( 'World' , TP3DTransform ) ; // Creating a P3D property that owns our transform object Properties . Add ( Prop ) ; // Add the property to the property list of the application. This way both the property and the object are freed automatically on termination FWorld := TP3DTransform . Create ( Prop ) ; // Create the object itself and specify it's owner: the property end ; In the SetupTriangle method we then pass the the transform object in the settings of our geometry. Optionally we also change the coordiates to that of an equilateral triangle with a center at the origin which is also used as a center for the rotation. procedure TMyApplication . SetupTriangle ; var h : Float ; begin h := sqrt ( 3 ) ; FTriangleList := layers ([ command_clear ([ cfColor , cfDepth ] , Grey500 ) , // Clear the background and depth buffer geom_polygon ([ vec3 ( - 1 ,- 1 / 3 * h , 0 ) , vec3 ( 1 , - 1 / 3 * h , 0 ) , vec3 ( 0 , 2 / 3 * h , 0 )] , // will form an equilateral triangle with a center at the origin settings ([ uniform_world ( World ) , attrib ( P3DAttribColor , [ Red500 , Green500 , Blue500 ]) ]) ) ) ; end ; In the render procedure we do our rotation for each frame. procedure TMyApplication . Render ; begin inherited Render ; World . Rotation := vec3 ( 0 , 0 , GetTickCount64 / 10 ) ; World . Scale := vec3 ( sin ( GetTickCount64 / 1000 ) / 4 + 0.25 ) ; // or by equivalently setting the matrix property // World.Matrix:= mat4rotate( vec3_Axis_PZ, GetTickCount64 / 1000 ) * mat4scale( vec4( vec3( sin( GetTickCount64 / 1000 ) / 4 + 0.25 ), 1 )); // The rotation is performed before the scale, which does however not matter in this case FTriangleList . Execute ; end ; Making the content adapt to a resize of the window When we resize the window depending on the ratio of width and height the content might look stretched and thus our triangle is not equilateral on the screen anymore. To prevent this we are going to use a Projection transform that covers the ratio of width and height. By default an identity matrix is used that assumes that the ratio of width and height is 1:1. This is however normally not the case. We add the Projection transform similar to the World transform by adding it to the application ... TMyApplication = class ( TP3DApplication ) private FProj : TP3DTransform ; ... public ... property Proj : TP3DTransform read FProj ; end ; ... and to the SetupTriangle and Initialize method. procedure TMyApplication . SetupTriangle ; var h : Float ; begin h := sqrt ( 3 ) ; FTriangleList := layers ([ command_clear ([ cfColor , cfDepth ] , Grey500 ) , // Clear the background and depth buffer geom_polygon ([ vec3 ( - 1 ,- 1 / 3 * h , 0 ) , vec3 ( 1 , - 1 / 3 * h , 0 ) , vec3 ( 0 , 2 / 3 * h , 0 )] , settings ([ uniform ( 'proj' , Proj ) , uniform_world ( World ) , attrib ( P3DAttribColor , [ Red500 , Green500 , Blue500 ]) ]) ) , geom_lines ( SineWave , settings ([ attrib ( P3DAttribColor , SineWaveColors ) ]) ) ]) ; end ; procedure TMyApplication . Initialize ; var Prop : TP3DStreamableContainer ; begin ... Prop := TP3DStreamableContainer . Create ( 'Proj' , TP3DTransform ) ; Properties . Add ( Prop ) ; FProj := TP3DTransform . Create ( Prop ) ; end ; We then override the ResizeWindow method that is called whenever the window is resized. TMyApplication = class ( TP3DApplication ) public ... procedure ResizeWindow ( Sender : TP3DWindow ; Event : TSDL_WindowEvent ) ; override ; end ; ... procedure TMyApplication . ResizeWindow ( Sender : TP3DWindow ; Event : TSDL_WindowEvent ) ; var Aspect : Extended ; begin inherited ResizeWindow ( Sender , Event ) ; Aspect := P3DViewports . Screen . Width // P3DViewports.Screen.Height; Calculate the ratio of width and height Proj . Scale := vec3 ( 1 / Aspect , 1 , 1 ) ; // and apply a scale to the visualization end ; Handling dynamic data Another advantage of a TP3DTransform object is that we don't have to update the render list in every frame although the visualization is different. P3DPlot is even capable of handling dynamic data that change their vertices or colors in every frame. To demonstrate that in the next step we are creating a scrolling sine wave with varying colors. In the main class of our application we have to add two new buffer objects. That of the coordinates and that of the colors. For the triangle we passed our coordiates in an array. We could have used buffers there as well. If we choose to use an array P3DPlot will create the buffer object behind the scene. With dynamic data however we have are restricted to buffers. The buffer object is however similar to an array and works like a TList object. The objects can have several types depending on the underlying data (eg. TP3DVec3BufferGL for a list of three component vectors). The auto suffix that has to be used with P3DPlot determines that the object is managed by the engine and is freed when there are no references to it anymore. This happens if when the object holding the variable is freed and it is not referenced by the plot list anymore. We chose a three component vector for the positions and a four component vector for the colors (RGBA). TMyApplication = class ( TP3DApplication ) private FSineWave : TP3DVec3BufferGLAuto ; FSineWaveColors : TP3DVec4BufferGLAuto ; ... public ... property SineWave : TP3DVec3BufferGLAuto read FSineWave ; property SineWaveColors : TP3DVec4BufferGLAuto read FSineWaveColors ; end ; As you can see the implementation is very straight forward. We add these lines to our SetupTriangle method. procedure TMyApplication . SetupTriangle ; var h : Float ; begin h := sqrt ( 3 ) ; FTriangleList := layers ([ command_clear ([ cfColor , cfDepth ] , Grey500 ) , // Clear the background and depth buffer geom_polygon ([ vec3 ( - 1 ,- 1 / 3 * h , 0 ) , vec3 ( 1 , - 1 / 3 * h , 0 ) , vec3 ( 0 , 2 / 3 * h , 0 )] , settings ([ uniform ( 'proj' , Proj ) , uniform_world ( World ) , attrib ( P3DAttribColor , [ Red500 , Green500 , Blue500 ]) ]) ) , geom_lines ( SineWave , settings ([ attrib ( P3DAttribColor , SineWaveColors ) ]) ) ]) ; end ; In the render procedure we have to fill the data. We set the count of the Buffers to 250 points for that but you can play with the number. I will not go into very much detail about the formula for the points. The color is composed by an HSV color model where we use the scaled looping variable to determine the hue of the vertex. Hint When working with dynamic data don't forget to call the PushData method after modifying it to transfer it to the OpenGL object of the buffer. procedure TMyApplication . Render ; const NumPoints = 250 ; var i : Integer ; begin inherited Render ; View . Rotation := vec3 ( 0 , 0 , GetTickCount64 / 10 ) ; View . Scale := vec3 ( sin ( GetTickCount64 / 1000 ) / 4 + 0.25 ) ; FSineWave . I . Count := NumPoints ; FSineWaveColors . I . Count := NumPoints ; for i := 0 to NumPoints - 1 do begin SineWave . I [ i ] := vec3 ( i / NumPoints * 2 - 1 , sin ( i / NumPoints * 50 + GetTickCount64 / 100 ) / 20 , 0.5 ) ; SineWaveColors . I [ i ] := vec4 ( P3DHSVToRGB ( vec3 ( sin ( i / NumPoints * 10 + GetTickCount64 / 100 ) / 2 + 0.5 , sin ( GetTickCount64 / 1000 ) / 4 + 0.75 , 1 )) , 1 - ( i / NumPoints )) ; end ; FSineWave . I . PushData ; FSineWaveColors . I . PushData ; FTriangleList . Execute ; end ;","title":"Rotating the triangle and dynamic data"},{"location":"tutorials/03-rotation-and-dynamic-data/#rotating-the-triangle-and-dynamic-data","text":"In the last example we learned how to render a static scene with a triangle. We will start with that and implement a rotation. Subsequently you will learn how to render dynamic data.","title":"Rotating the triangle and dynamic data"},{"location":"tutorials/03-rotation-and-dynamic-data/#the-transform-class","text":"For describing the rotation a matrix is used. For a general introduction on vectors, matrices and transforms I can recommend this tutorial . For Pascal3D you do not necessarily understand how matrices are composed, though it helps. In Pascal3D a transform can be described with the TP3DTransform class. It is a frontend for all the common transformations (Translation, rotation, scale) which are then assembled to a matrix. In 3D math rotations can be described by matrices, euler angles or by quaternions (There are even more methods). TP3DTransform = class ( TP3DStreamable ) ... // Common translations --> property Position : TVec3 ; // Translation for moving the scene property Scale : TVec3 ; // Scaling the scene along the global axes // for rotation use property Rotation : TVec3 ; // Rotation with euler angles around the global axes (XYZ) // or property Quaternion : TQuat ; // Rotation in quaternion style (useful for bones, not prone to gimbal lock) // the other is then updated automatically // <-- Common translations property Direction : TVec3 ; // Where is the transformed object pointing (useful for cameras or lights) [readonly] property Matrix : TMat4 ; // Matrix that contains all the above transforms property MatrixInv : TMat4 ; // Inverse matrix to undo the transformation property RotationOrder : TRotationOrder ; // Determines in which order the transforms are applied end ; The above listing shows the important properties of a TP3DTransform object in pseudo code. You can edit any of these and the others are automatically updated if necessary. Use the Position property if you want to shift the scene, the Scale property to for applying a scale and one of the two rotation types ( Rotation or Quaternion ) to rotate the scene. You can also set the Matrix property if you prefer to. The transformations are typically distinguished between World , View and Projection . In the former the scene is transformed, in the second the camera. The difference is that to get the same visual results a View transform has to be opposite or inverse of the world transform. A camera that moves to the right, for example, causes the scene to shift optically to the left. The Projection transform decides how the three-dimensional scene is displayed on the screen. This can be either orthogonal or perspective. Finally there is the RotationOrder . This determines which transformation is applied first. First moving a scene and then rotating it results in a different effect than the other way round.","title":"The transform class"},{"location":"tutorials/03-rotation-and-dynamic-data/#transforming-the-triangle","text":"In this tutorial we use a world transform to rotate the triangle itself. Extending the code from the previous tutorial we can pass our World: TP3DTransform object in the settings of our triangle. However we first have to create our World transform object. TMyApplication = class ( TP3DApplication ) private FWorld : TP3DTransform ; ... public ... property World : TP3DTransform read FWorld ; end ; And in our Initialize method we have to create the object on initialization. We create a P3D property that is the owner of the World object. We don't need to free it ourselves then as this is done automatically when the program terminates. procedure TMyApplication . Initialize ; var Prop : TP3DStreamableContainer ; // Use a local variable for the property as we do not need to keep track of it begin ... Prop := TP3DStreamableContainer . Create ( 'World' , TP3DTransform ) ; // Creating a P3D property that owns our transform object Properties . Add ( Prop ) ; // Add the property to the property list of the application. This way both the property and the object are freed automatically on termination FWorld := TP3DTransform . Create ( Prop ) ; // Create the object itself and specify it's owner: the property end ; In the SetupTriangle method we then pass the the transform object in the settings of our geometry. Optionally we also change the coordiates to that of an equilateral triangle with a center at the origin which is also used as a center for the rotation. procedure TMyApplication . SetupTriangle ; var h : Float ; begin h := sqrt ( 3 ) ; FTriangleList := layers ([ command_clear ([ cfColor , cfDepth ] , Grey500 ) , // Clear the background and depth buffer geom_polygon ([ vec3 ( - 1 ,- 1 / 3 * h , 0 ) , vec3 ( 1 , - 1 / 3 * h , 0 ) , vec3 ( 0 , 2 / 3 * h , 0 )] , // will form an equilateral triangle with a center at the origin settings ([ uniform_world ( World ) , attrib ( P3DAttribColor , [ Red500 , Green500 , Blue500 ]) ]) ) ) ; end ; In the render procedure we do our rotation for each frame. procedure TMyApplication . Render ; begin inherited Render ; World . Rotation := vec3 ( 0 , 0 , GetTickCount64 / 10 ) ; World . Scale := vec3 ( sin ( GetTickCount64 / 1000 ) / 4 + 0.25 ) ; // or by equivalently setting the matrix property // World.Matrix:= mat4rotate( vec3_Axis_PZ, GetTickCount64 / 1000 ) * mat4scale( vec4( vec3( sin( GetTickCount64 / 1000 ) / 4 + 0.25 ), 1 )); // The rotation is performed before the scale, which does however not matter in this case FTriangleList . Execute ; end ;","title":"Transforming the triangle"},{"location":"tutorials/03-rotation-and-dynamic-data/#making-the-content-adapt-to-a-resize-of-the-window","text":"When we resize the window depending on the ratio of width and height the content might look stretched and thus our triangle is not equilateral on the screen anymore. To prevent this we are going to use a Projection transform that covers the ratio of width and height. By default an identity matrix is used that assumes that the ratio of width and height is 1:1. This is however normally not the case. We add the Projection transform similar to the World transform by adding it to the application ... TMyApplication = class ( TP3DApplication ) private FProj : TP3DTransform ; ... public ... property Proj : TP3DTransform read FProj ; end ; ... and to the SetupTriangle and Initialize method. procedure TMyApplication . SetupTriangle ; var h : Float ; begin h := sqrt ( 3 ) ; FTriangleList := layers ([ command_clear ([ cfColor , cfDepth ] , Grey500 ) , // Clear the background and depth buffer geom_polygon ([ vec3 ( - 1 ,- 1 / 3 * h , 0 ) , vec3 ( 1 , - 1 / 3 * h , 0 ) , vec3 ( 0 , 2 / 3 * h , 0 )] , settings ([ uniform ( 'proj' , Proj ) , uniform_world ( World ) , attrib ( P3DAttribColor , [ Red500 , Green500 , Blue500 ]) ]) ) , geom_lines ( SineWave , settings ([ attrib ( P3DAttribColor , SineWaveColors ) ]) ) ]) ; end ; procedure TMyApplication . Initialize ; var Prop : TP3DStreamableContainer ; begin ... Prop := TP3DStreamableContainer . Create ( 'Proj' , TP3DTransform ) ; Properties . Add ( Prop ) ; FProj := TP3DTransform . Create ( Prop ) ; end ; We then override the ResizeWindow method that is called whenever the window is resized. TMyApplication = class ( TP3DApplication ) public ... procedure ResizeWindow ( Sender : TP3DWindow ; Event : TSDL_WindowEvent ) ; override ; end ; ... procedure TMyApplication . ResizeWindow ( Sender : TP3DWindow ; Event : TSDL_WindowEvent ) ; var Aspect : Extended ; begin inherited ResizeWindow ( Sender , Event ) ; Aspect := P3DViewports . Screen . Width // P3DViewports.Screen.Height; Calculate the ratio of width and height Proj . Scale := vec3 ( 1 / Aspect , 1 , 1 ) ; // and apply a scale to the visualization end ;","title":"Making the content adapt to a resize of the window"},{"location":"tutorials/03-rotation-and-dynamic-data/#handling-dynamic-data","text":"Another advantage of a TP3DTransform object is that we don't have to update the render list in every frame although the visualization is different. P3DPlot is even capable of handling dynamic data that change their vertices or colors in every frame. To demonstrate that in the next step we are creating a scrolling sine wave with varying colors. In the main class of our application we have to add two new buffer objects. That of the coordinates and that of the colors. For the triangle we passed our coordiates in an array. We could have used buffers there as well. If we choose to use an array P3DPlot will create the buffer object behind the scene. With dynamic data however we have are restricted to buffers. The buffer object is however similar to an array and works like a TList object. The objects can have several types depending on the underlying data (eg. TP3DVec3BufferGL for a list of three component vectors). The auto suffix that has to be used with P3DPlot determines that the object is managed by the engine and is freed when there are no references to it anymore. This happens if when the object holding the variable is freed and it is not referenced by the plot list anymore. We chose a three component vector for the positions and a four component vector for the colors (RGBA). TMyApplication = class ( TP3DApplication ) private FSineWave : TP3DVec3BufferGLAuto ; FSineWaveColors : TP3DVec4BufferGLAuto ; ... public ... property SineWave : TP3DVec3BufferGLAuto read FSineWave ; property SineWaveColors : TP3DVec4BufferGLAuto read FSineWaveColors ; end ; As you can see the implementation is very straight forward. We add these lines to our SetupTriangle method. procedure TMyApplication . SetupTriangle ; var h : Float ; begin h := sqrt ( 3 ) ; FTriangleList := layers ([ command_clear ([ cfColor , cfDepth ] , Grey500 ) , // Clear the background and depth buffer geom_polygon ([ vec3 ( - 1 ,- 1 / 3 * h , 0 ) , vec3 ( 1 , - 1 / 3 * h , 0 ) , vec3 ( 0 , 2 / 3 * h , 0 )] , settings ([ uniform ( 'proj' , Proj ) , uniform_world ( World ) , attrib ( P3DAttribColor , [ Red500 , Green500 , Blue500 ]) ]) ) , geom_lines ( SineWave , settings ([ attrib ( P3DAttribColor , SineWaveColors ) ]) ) ]) ; end ; In the render procedure we have to fill the data. We set the count of the Buffers to 250 points for that but you can play with the number. I will not go into very much detail about the formula for the points. The color is composed by an HSV color model where we use the scaled looping variable to determine the hue of the vertex. Hint When working with dynamic data don't forget to call the PushData method after modifying it to transfer it to the OpenGL object of the buffer. procedure TMyApplication . Render ; const NumPoints = 250 ; var i : Integer ; begin inherited Render ; View . Rotation := vec3 ( 0 , 0 , GetTickCount64 / 10 ) ; View . Scale := vec3 ( sin ( GetTickCount64 / 1000 ) / 4 + 0.25 ) ; FSineWave . I . Count := NumPoints ; FSineWaveColors . I . Count := NumPoints ; for i := 0 to NumPoints - 1 do begin SineWave . I [ i ] := vec3 ( i / NumPoints * 2 - 1 , sin ( i / NumPoints * 50 + GetTickCount64 / 100 ) / 20 , 0.5 ) ; SineWaveColors . I [ i ] := vec4 ( P3DHSVToRGB ( vec3 ( sin ( i / NumPoints * 10 + GetTickCount64 / 100 ) / 2 + 0.5 , sin ( GetTickCount64 / 1000 ) / 4 + 0.75 , 1 )) , 1 - ( i / NumPoints )) ; end ; FSineWave . I . PushData ; FSineWaveColors . I . PushData ; FTriangleList . Execute ; end ;","title":"Handling dynamic data"}]}