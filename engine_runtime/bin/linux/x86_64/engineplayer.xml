<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xml" href="#stylesheet"?>
<p3dlog>
  <xsl:stylesheet id="stylesheet" version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template match="xsl:stylesheet"/>
    <xsl:template match="/">
      <html>
        <head>
          <style>h1{
      font-family: Roboto Sans, Arial;
      font-size: 32px;
      }
      td,th{
      font-family: Roboto Sans, Arial;
      white-space: pre-wrap;
      text-align:left;
      vertical-align: top;
      }
      .info{
      background-color: rgb(255, 255, 230);
      }
      .exception{
      background-color: rgb(255, 194, 153);
      }
     </style>
        </head>
        <body>
          <h1>Logfile</h1>
          <table>
            <tr>
              <th>Time</th>
              <th>Message</th>
            </tr>
            <xsl:apply-templates/>
          </table>
        </body>
      </html>
    </xsl:template>
    <xsl:template match="info">
      <tr class="info">
        <td>
          <xsl:value-of select="@Time"/>
        </td>
        <td>
          <xsl:value-of select="."/>
        </td>
      </tr>
    </xsl:template>
    <xsl:template match="exception">
      <tr class="exception">
        <td>
          <xsl:value-of select="@Time"/>
        </td>
        <td>
          <xsl:value-of select="."/>
        </td>
      </tr>
    </xsl:template>
  </xsl:stylesheet>
  <info Time="0" Unit="p3devents" Sender="TP3DApplication" function="SetMainWindow">SetMainWindow</info>
  <info Time="565" Unit="p3devents" Sender="TP3DApplication" function="SetMainWindow">SetMainWindow</info>
  <info Time="566" Unit="p3devents" Sender="TP3DApplication" function="Initialize">initializing application</info>
  <info Time="3411" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord0 = TexMat0 * vTexCoord0;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3412" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
uniform sampler2D tex0;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3420" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord0 = TexMat0 * vTexCoord0;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3421" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
uniform sampler2D tex0;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3423" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord0 = TexMat0 * vTexCoord0;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3424" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
uniform sampler2D tex0;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3468" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
/* layout ( location = 9 ) */ IN vec4 TexCoord1;
OUT vec4 vTexCoord1;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat1 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;
uniform sampler2D tex1;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord1 = TexCoord1;
vTexCoord0 = TexMat0 * vTexCoord0;
vTexCoord1 = TexMat1 * vTexCoord1;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Displace= mix( Displace, color_mix( vec4( Displace ), val1.aaaa ).a, -100 );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3470" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
IN vec4 vTexCoord1;
uniform sampler2D tex0;
uniform sampler2D tex1;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val1.xyz *2 - 1, 0 )), 1 );
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3547" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
/* layout ( location = 9 ) */ IN vec4 TexCoord1;
OUT vec4 vTexCoord1;
/* layout ( location = 10 ) */ IN vec4 TexCoord2;
OUT vec4 vTexCoord2;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat1 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat2 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord1 = TexCoord1;
vTexCoord2 = TexCoord2;
vTexCoord0 = TexMat0 * vTexCoord0;
vTexCoord1 = TexMat1 * vTexCoord1;
vTexCoord2 = TexMat2 * vTexCoord2;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Displace= mix( Displace, color_mix( vec4( Displace ), val1.aaaa ).a, -100 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3548" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
IN vec4 vTexCoord1;
IN vec4 vTexCoord2;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val1.xyz *2 - 1, 0 )), 1 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val2 ).rgb, 0.1000000015 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val2.a )).a, 0 );
//MIX INDEPENTLY
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3551" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
/* layout ( location = 9 ) */ IN vec4 TexCoord1;
OUT vec4 vTexCoord1;
/* layout ( location = 10 ) */ IN vec4 TexCoord2;
OUT vec4 vTexCoord2;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat1 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat2 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord1 = TexCoord1;
vTexCoord2 = TexCoord2;
vTexCoord0 = TexMat0 * vTexCoord0;
vTexCoord1 = TexMat1 * vTexCoord1;
vTexCoord2 = TexMat2 * vTexCoord2;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Displace= mix( Displace, color_mix( vec4( Displace ), val1.aaaa ).a, -100 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3553" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
IN vec4 vTexCoord1;
IN vec4 vTexCoord2;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val1.xyz *2 - 1, 0 )), 1 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val2 ).rgb, 0.1000000015 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val2.a )).a, 0 );
//MIX INDEPENTLY
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3561" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
/* layout ( location = 9 ) */ IN vec4 TexCoord1;
OUT vec4 vTexCoord1;
/* layout ( location = 10 ) */ IN vec4 TexCoord2;
OUT vec4 vTexCoord2;
/* layout ( location = 11 ) */ IN vec4 TexCoord3;
OUT vec4 vTexCoord3;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat1 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat2 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat3 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord1 = TexCoord1;
vTexCoord2 = TexCoord2;
vTexCoord3 = TexCoord3;
vTexCoord0 = TexMat0 * vTexCoord0;
vTexCoord1 = TexMat1 * vTexCoord1;
vTexCoord2 = TexMat2 * vTexCoord2;
vTexCoord3 = TexMat3 * vTexCoord3;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Displace= mix( Displace, color_mix( vec4( Displace ), val1.aaaa ).a, -100 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
vec4 val3 = texture2D( tex3, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3563" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
IN vec4 vTexCoord1;
IN vec4 vTexCoord2;
IN vec4 vTexCoord3;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val1.xyz *2 - 1, 0 )), 1 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val2 ).rgb, 0.1000000015 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val2.a )).a, 0 );
//MIX INDEPENTLY
vec4 val3 = texture2D( tex3, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val3.xyz *2 - 1, 0 )), 0.1000000015 );
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3566" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
/* layout ( location = 9 ) */ IN vec4 TexCoord1;
OUT vec4 vTexCoord1;
/* layout ( location = 10 ) */ IN vec4 TexCoord2;
OUT vec4 vTexCoord2;
/* layout ( location = 11 ) */ IN vec4 TexCoord3;
OUT vec4 vTexCoord3;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat1 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat2 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat3 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord1 = TexCoord1;
vTexCoord2 = TexCoord2;
vTexCoord3 = TexCoord3;
vTexCoord0 = TexMat0 * vTexCoord0;
vTexCoord1 = TexMat1 * vTexCoord1;
vTexCoord2 = TexMat2 * vTexCoord2;
vTexCoord3 = TexMat3 * vTexCoord3;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Displace= mix( Displace, color_mix( vec4( Displace ), val1.aaaa ).a, -100 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
vec4 val3 = texture2D( tex3, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3568" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
IN vec4 vTexCoord1;
IN vec4 vTexCoord2;
IN vec4 vTexCoord3;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val1.xyz *2 - 1, 0 )), 1 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val2 ).rgb, 0.1000000015 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val2.a )).a, 0 );
//MIX INDEPENTLY
vec4 val3 = texture2D( tex3, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val3.xyz *2 - 1, 0 )), 0.1000000015 );
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3572" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
/* layout ( location = 9 ) */ IN vec4 TexCoord1;
OUT vec4 vTexCoord1;
/* layout ( location = 10 ) */ IN vec4 TexCoord2;
OUT vec4 vTexCoord2;
/* layout ( location = 11 ) */ IN vec4 TexCoord3;
OUT vec4 vTexCoord3;
/* layout ( location = 12 ) */ IN vec4 TexCoord4;
OUT vec4 vTexCoord4;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat1 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat2 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat3 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
const mat4 TexMat4 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;
uniform sampler2D tex4;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord1 = TexCoord1;
vTexCoord2 = TexCoord2;
vTexCoord3 = TexCoord3;
vTexCoord4 = TexCoord4;
vTexCoord0 = TexMat0 * vTexCoord0;
vTexCoord1 = TexMat1 * vTexCoord1;
vTexCoord2 = TexMat2 * vTexCoord2;
vTexCoord3 = TexMat3 * vTexCoord3;
vTexCoord4 = TexMat4 * vTexCoord4;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Displace= mix( Displace, color_mix( vec4( Displace ), val1.aaaa ).a, -100 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
vec4 val3 = texture2D( tex3, vTexCoord0.xy );
vec4 val4 = texture2D( tex4, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3574" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
IN vec4 vTexCoord1;
IN vec4 vTexCoord2;
IN vec4 vTexCoord3;
IN vec4 vTexCoord4;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;
uniform sampler2D tex4;

#define PI 3.14159
#define PI2 6.28318
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {

  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  float distance = dot( planeNormal, point - pointOnPlane );

  return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

  return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {

  if ( decayExponent &gt; 0.0 ) {

    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

  }

  return 1.0;

}

vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {

  // Original approximation by Christophe Schlick '94
  //;float fresnel = pow( 1.0 - dotLH, 5.0 );

  // Optimized variant (presented by Epic at SIGGRAPH '13)
  float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );

  return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {

  // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)

  return 0.25;

}

float D_BlinnPhong( in float shininess, in float dotNH ) {

  // factor of 1/PI in distribution term omitted

  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {

  vec3 halfDir = normalize( lightDir + viewDir );

  //float dotNL = saturate( dot( normal, lightDir ) );
  //float dotNV = saturate( dot( normal, viewDir ) );
  float dotNH = saturate( dot( normal, halfDir ) );
  float dotLH = saturate( dot( lightDir, halfDir ) );

  vec3 F = F_Schlick( specularColor, dotLH );

  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

  float D = D_BlinnPhong( shininess, dotNH );

  return F * G * D;

}

vec3 inputToLinear( in vec3 a ) {

  #ifdef GAMMA_INPUT

    return pow( a, vec3( float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 linearToOutput( in vec3 a ) {

  #ifdef GAMMA_OUTPUT

    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );

  #else

    return a;

  #endif

}

vec3 transformToTangentSpace( vec3 v ){
return vec3(
  dot( v, vTangent.xyz),
  dot( v, vCotangent.xyz),
  dot( v, vNormal.xyz));
}
const int p3dltPoint = 0;
const int p3dltSun = 1;
const int p3dltSpot = 2;

struct LightSourceParameters {
  vec4 color;
  vec4 position;
  vec4 halfvector;
  vec4 direction;
  int type;
//  float spotExponent;
//  float spotCutoff; // (range: [0.0,90.0], 180.0)
//  float spotCosCutoff; // (range: [1.0,0.0],-1.0)
//  float constantAttenuation;
  float linearAttenuation;
  float quadraticAttenuation;
};
uniform int numLightSource;
uniform LightSourceParameters LightSource[8];


vec3 viewDir;

/*float calculateAttenuation(in int i, in float dist)
{
    return(1.0 / (max( 0.01, 
                  LightSource[i].linearAttenuation * dist +
                  LightSource[i].quadraticAttenuation * dist * dist)));
}*/
void util_PointLight( in int i, in float shininess,                  
                      in vec3 N, inout vec3 diffuse, inout vec3 specular )

{
    vec3 lVector = ( LightSource[ i ].position.xyz - vPosition.xyz );
    vec3 lightDir = normalize( lVector );

    // attenuation

    float attenuation = 1;//calcLightAttenuation( length( lVector ), 1, 0.1 ); //pointLightDistance[ i ], pointLightDecay[ i ] );

    // diffuse

    float cosineTerm = saturate( dot( N, lightDir ) );

    diffuse += LightSource[ i ].color.rgb * attenuation * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, lightDir, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * attenuation * cosineTerm;
}

/*{
    vec3 s = ( LightSource[ i ].position.xyz - vPosition.xyz );
    float dist = length( s );
    s = s / dist;
    vec3 v = normalize( -vPosition.xyz );
    vec3 r = reflect( -s, N );
    float attenuation = calculateAttenuation(i, dist);
    float sDotN = max( dot(s,N), 0.0 );

      specular= clamp( specular + 
      vec4( LightSource[ i ].color.rgb, 1 ) *
         pow( dot(r,v), shininess ) * attenuation, 0.0, 1.0 );

    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * sDotN * attenuation, 0.0, 1.0 );
}*/
void util_directionalLight( in int i,
                            in float shininess,
                            in vec3 N,
                            inout vec3 diffuse,
                            inout vec3 specular )
{
/*    float nDotVP;   // normal . light direction
    float nDotHV;   // normal . light half vector
    float pf;   // power factor
    
    nDotVP = clamp( dot( N, -normalize( transformToTangentSpace( LightSource[ i ].direction.xyz ))), 0.0, 1.0 );
    nDotHV = clamp( dot( N, normalize( LightSource[ i ].halfvector.xyz )), 0.0, 1.0 );
    pf = pow( nDotHV, shininess );
    diffuse = clamp( diffuse + vec4( LightSource[ i ].color.rgb, 1 ) * nDotVP, 0.0, 1.0 );
    specular = clamp( specular + vec4( LightSource[ i ].color.rgb, 1 ) * pf, 0.0, 1.0 );*/


    // diffuse

    float cosineTerm = saturate( dot( N, LightSource[ i ].direction.xyz ));

    diffuse += LightSource[ i ].color.rgb * cosineTerm;

    // specular

    vec3 brdf = BRDF_BlinnPhong( vec3( 1 ), shininess, N, LightSource[ i ].direction.xyz, viewDir );

    specular += brdf * LightSource[ i ].color.rgb * cosineTerm;
}
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
vec4 val1 = texture2D( tex1, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val1.xyz *2 - 1, 0 )), 1 );
vec4 val2 = texture2D( tex2, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val2 ).rgb, 0.1000000015 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val2.a )).a, 0 );
//MIX INDEPENTLY
vec4 val3 = texture2D( tex3, vTexCoord0.xy );
Normal= mix( Normal, color_mix( Normal, vec4( val3.xyz *2 - 1, 0 )), 0.1000000015 );
vec4 val4 = texture2D( tex4, vTexCoord0.xy );
Specular= mix( Specular, color_mix( Specular, val4 ), 0.1000000015 );
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 0 );
  vec3 spec = vec3( 0 );
  viewDir = normalize( -vPosition.xyz );
  for ( int i=0; i &lt; numLightSource; i++ ) {
    if ( LightSource[ i ].type == p3dltPoint )
      util_PointLight( i, mat_hardness, Normal.xyz, shadow, spec );
    if ( LightSource[ i ].type == p3dltSun )
      util_directionalLight( i, mat_hardness, Normal.xyz, shadow, spec );
  }
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3824" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;
void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord0 = TexMat0 * vTexCoord0;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3826" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
uniform sampler2D tex0;
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 1 );
  vec3 spec = vec3( 0 );
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3837" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
/* layout ( location = 8 ) */ IN vec4 TexCoord0;
OUT vec4 vTexCoord0;
const mat4 TexMat0 = mat4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
uniform sampler2D tex0;
void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vTexCoord0 = TexCoord0;
vTexCoord0 = TexMat0 * vTexCoord0;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3839" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
IN vec4 vTexCoord0;
uniform sampler2D tex0;
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
vec4 val0 = texture2D( tex0, vTexCoord0.xy );
Color.rgb = mix( Color.rgb, color_mix( Color, val0 ).rgb, 1 );
Color.a = mix( Color.a, color_mix( vec4( Color.a ), vec4( val0.a )).a, 0 );
//MIX INDEPENTLY
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 1 );
  vec3 spec = vec3( 0 );
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <info Time="3842" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
void main(){
float Displace = 0.0;
vPosition = Position;
vColor = Color;
vNormal = world * vec4( Normal.xyz, 0 );
vTangent = world * vec4( Tangent.xyz, 0 );
vCotangent = world * vec4( Cotangent.xyz, 0 );
vPosition = view * world * ( vPosition + Displace * vNormal );
//cameye = - ( view * Position ).xyz;
gl_Position = proj * vPosition;
}
&amp;lt; End of Shader</info>
  <info Time="3845" Unit="p3dgraphics" Sender="TP3DShaderNodeTree">Built shader from chunks &amp;gt;
#version 120
#if (__VERSION__ &gt; 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
uniform mat4 world;
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
void main(){
vec4 Normal = vec4( 0, 0, 1, 0 );
vec4 Color = vec4( 1 );
vec4 Specular = mat_specular;
Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
Normal = normalize( view * vec4( Normal.xyz, 0 ));
  vec3 shadow = vec3( 1 );
  vec3 spec = vec3( 0 );
FragColor = vec4( Color.rgb * vColor.rgb * shadow.rgb + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
#if (__VERSION__ &lt; 130)
gl_FragColor = FragColor;
#endif
}
&amp;lt; End of Shader</info>
  <exception Time="3847">p3dshaders.inc(407): OpenGL Error: invalid enumerant</exception>
  <info Time="3852" Unit="p3devents" Sender="TP3DApplication" function="Run">Running application</info>
  <info Time="6619" Unit="p3devents" Sender="TP3DApplication">exit mainloop</info>
</p3dlog>
