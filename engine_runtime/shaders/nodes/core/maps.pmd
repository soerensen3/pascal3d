---
node: 10_map_lib
---

```{name="CODE", type="shader", restrict="declaration,vshader"}
#if (__VERSION__ > 120)
# define IN in
# define OUT out
#else
# define IN attribute
# define OUT varying
#endif
```

```{name="CODE", type="shader", restrict="declaration,fshader"}
#if (__VERSION__ > 120)
# define IN in
# define OUT out
#else
# define IN varying
# define OUT  
#endif
```

```{restrict="declaration"}
uniform mat4 view;
uniform mat3 matnormal;
uniform mat4 proj;
uniform vec3 campos;
vec4 CalcBumpedNormal(vec4 Normal,vec4 Tangent, vec4 Cotangent, vec4 BumpMapNormal)
{
    //BumpMapNormal = vec4( 2.0 * BumpMapNormal.xyz - vec3(1.0, 1.0, 1.0), 1 );
    vec4 NewNormal;
    mat3 TBN = mat3(Tangent.xyz, Cotangent.xyz, Normal.xyz);
    NewNormal = vec4( TBN * BumpMapNormal.xyz, 1 );
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

vec4 color_add( vec4 v1, vec4 v2 ){
  return v1 + v2;
}

vec4 color_sub( vec4 v1, vec4 v2 ){
  return v1 - v2;
}

vec4 color_mul( vec4 v1, vec4 v2 ){
  return v1 * v2;
}

vec4 color_div( vec4 v1, vec4 v2 ){
  return v1 / v2;
}

vec4 color_mix( vec4 v1, vec4 v2 ){
  return v2;
}

vec3 color_overlay(vec3 base, vec3 blend) {
  return mix(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, step(base, vec3(0.5)));
}

vec3 color_overlay_light(vec3 base, vec3 blend) {
  return base * blend;
  //not worth the effort
  //mix(1.0 - (2.0 - base) * (1.0 - blend), base * blend, step(base, vec3(1)));
}

```

---
node: 10_map_texcoord_init
input: {name="Location", type="int"}
input: {name="TexCoordIndex", type="int"}
---
```{name="CODE", type="shader", restrict="vshader,declaration"}
/* layout ( location = $Location$ ) */ IN vec4 TexCoord$TexCoordIndex$;
```

---
node: 10_map_init
input: {name="MapIndex", type="int"}
input: {name="TexCoordIndex", type="int"}
---
```{name="CODE", type="shader", restrict="vshader,declaration"}
OUT vec4 vTexCoord$MapIndex$;
```

```{restrict="vshader,main"}
  vTexCoord$MapIndex$ = TexCoord$TexCoordIndex$;
```

```{restrict="fshader,declaration"}
IN vec4 vTexCoord$MapIndex$;
```

---
node: 50_map_texcoord_transform_dynamic
input: {name="TexCoordIndex", type="int"}
---
```{name="CODE", type="shader", restrict="vshader,declaration"}
uniform mat4 TexMat$TexCoordIndex$;
```

```{restrict="vshader,main"}
  vTexCoord$TexCoordIndex$ = TexMat$TexCoordIndex$ * vTexCoord$TexCoordIndex$;

```
---
node: 50_map_texcoord_transform_fixed
input: {name="TexCoordIndex", type="int"}
input: {name="Transform", type="mat4"}
---
```{name="CODE", type="shader", restrict="vshader,declaration"}
const mat4 TexMat$TexCoordIndex$ = $Transform$;
```

```{restrict="vshader,main"}
  vTexCoord$TexCoordIndex$ = TexMat$TexCoordIndex$ * vTexCoord$TexCoordIndex$;
```

---
node: 10_map_pass_init
---

```{name="CODE", type="shader", restrict="vshader,declaration"}
/*layout ( location = 0 ) */ IN vec4 Position;
/*layout ( location = 2 ) */ IN vec4 Normal;
/*layout ( location = 3 ) */ IN vec4 Color;
/*layout ( location = 6 ) */ IN vec4 Cotangent;
/*layout ( location = 7 ) */ IN vec4 Tangent;
OUT vec4 vNormal;
OUT vec4 vColor;
OUT vec4 vTangent;
OUT vec4 vCotangent;
OUT vec4 vPosition;
OUT vec3 cameye;
```

```{restrict="vshader,main"}
  float Displace = 0.0;
  vPosition = Position;
  vColor = Color;
  vNormal = vec4( Normal.xyz, 0 );
  vTangent = vec4( Tangent.xyz, 0 );
  vCotangent = vec4( Cotangent.xyz, 0 );
```


```{restrict="fshader,declaration"}
IN vec4 vNormal;
IN vec4 vColor;
IN vec4 vTangent;
IN vec4 vCotangent;
IN vec4 vPosition;
IN vec3 cameye;
OUT vec4 FragColor;

uniform vec4 mat_specular;
uniform float mat_hardness;
```

```{restrict="fshader,main"}
  vec4 Normal = vec4( 0, 0, 1, 0 );
  vec4 Color = vec4( 1 );
  vec4 Specular = mat_specular;
```

---
node: 30_map_pass_world_transform
---
```{name="CODE", type="shader", restrict="vshader,declaration"}
uniform mat4 world;
mat4 mWorld = world;
```

```{name="CODE", type="shader", restrict="vshader,main"}
  vPosition = mWorld * vPosition;
  vNormal = mWorld * vec4( vNormal.xyz, 0 );
  vTangent = mWorld * vec4( vTangent.xyz, 0 );
  vCotangent = mWorld * vec4( vCotangent.xyz, 0 );
```

---
node: 30_map_pass_world_transform_init_instanced
---

```{name="CODE", type="shader", restrict="vshader,extensions"}
#extension GL_ARB_draw_instanced : require
```

---
node: 40_map_pass_world_transform_init_instanced_attrib
---

```{name="CODE", type="shader", restrict="vshader,declaration"}
IN vec3 instance_position;
IN vec4 instance_rotation;
IN vec3 instance_scaling;

vec3 rotate_quat( vec3 p, vec4 q )
{ 
  //return p + 2.0 * cross( q.xyz, cross( q.xyz, p ) + q.w * p );
  return p + 2.0 * cross( cross( p, q.xyz ) + q.w * p, q.xyz );
}
```

```{restrict="vshader,main"}
  vPosition = vec4( rotate_quat( instance_scaling * vPosition.xyz, instance_rotation ), 1 );
  vPosition.xyz = vPosition.xyz + instance_position;
  vNormal.xyz = rotate_quat( instance_scaling * vNormal.xyz, instance_rotation );
  vTangent.xyz = rotate_quat( instance_scaling * vTangent.xyz, instance_rotation );
  vCotangent.xyz = rotate_quat( instance_scaling * vCotangent.xyz, instance_rotation );
```

---
node: 40_map_pass_world_transform_init_instanced_texture
---
```{name="CODE", type="shader", restrict="vshader,declaration"}
uniform sampler2D world_instance;
uniform int world_instance_w;
uniform int world_instance_h;
uniform int world_instance_repeat;

//Credit goes to three.js skinning_pars_vertex.glsl
mat4 getTexMatrix( float i ) {
	float j = i * 4.0;
	float x = mod( j, float( world_instance_w ));
	float y = floor( j / float( world_instance_w ));

	float dx = 1.0 / float( world_instance_w );
	float dy = 1.0 / float( world_instance_h );

	y = dy * ( y + 0.5 );

	vec4 v1 = texture2D( world_instance, vec2( dx * ( x + 0.5 ), y ));
	vec4 v2 = texture2D( world_instance, vec2( dx * ( x + 1.5 ), y ));
	vec4 v3 = texture2D( world_instance, vec2( dx * ( x + 2.5 ), y ));
	vec4 v4 = texture2D( world_instance, vec2( dx * ( x + 3.5 ), y ));

	return mat4( v1, v2, v3, v4 );
}
```

```{restrict="vshader,main"}
  mWorld = getTexMatrix( mod( gl_InstanceID, world_instance_repeat ));
```

---
node: 50_map_pass_world_transform_init_instanced_grid
---
```{name="CODE", type="shader", restrict="vshader,declaration"}
uniform int instanceGridWidth = 1;
uniform float instanceGridWorldSize = 1.0;
IN float instanceID;
```

```{restrict="vshader,main"}
  vPosition.xy += vec2( mod( instanceID, instanceGridWidth ), floor( instanceID / instanceGridWidth )) * instanceGridWorldSize;
```

---
node: 100_map_pass_combine
---

```{name="mix", type="text" restrict="main"}
color_mix```

```{name="multiply", type="text" restrict="main"}
color_mul```

```{name="add", type="text" restrict="main"}
color_add```

```{name="subtract", type="text" restrict=main}
color_sub```

---

node: 100_map_pass_read_frag
input: {name="TexCoordIndex", type="int"}
input: {name="Index", type="int"}
---

```{name="CODE", type="shader", restrict="fshader,declaration"}
uniform sampler2D tex$Index$;
```

```{restrict="fshader,main"}
  vec4 val$Index$ = texture2D( tex$Index$, vTexCoord$TexCoordIndex$.xy );
```

---
node: 100_map_pass_read_vert
input: {name="TexCoordIndex", type="int"}
input: {name="Index", type="int"}
---

```{name="CODE", type="shader", restrict="vshader,declaration"}
uniform sampler2D tex$Index$;
```

```{restrict="vshader,main"}
  vec4 val$Index$ = texture2D( tex$Index$, vTexCoord$TexCoordIndex$.xy );
```

---
node: 100_map_pass_displace
input: {name="Index", type="int"}
input: {name="Factor", type="float"}
input: {name="Mode", type="text"}
---

```{name="CODE", type="shader", restrict="vshader,main"}
  Displace= mix( Displace, $Mode$( vec4( Displace ), val$Index$.aaaa ).a, $Factor$ );
```

---
node: 100_map_pass_normal
input: {name="Index", type="int"}
input: {name="Factor", type="float"}
input: {name="Mode", type="text"}
---

```{name="CODE", type="shader", restrict="fshader,main"}
  Normal= mix( Normal, $Mode$( Normal, vec4( val$Index$.xyz *2 - 1, 0 )), $Factor$ );
```

---
node: 100_map_pass_diffuse
input: {name="Index", type="int"}
input: {name="Factor", type="float"}
input: {name="Alpha", type="float"}
input: {name="Mode", type="text"}
---

```{name="CODE", type="shader", restrict="fshader,main"}
  Color.rgb = mix( Color.rgb, $Mode$( Color, val$Index$ ).rgb, $Factor$ );
  Color.a = mix( Color.a, $Mode$( vec4( Color.a ), vec4( val$Index$.a )).a, $Alpha$ );
//MIX INDEPENTLY
```


---
node: 100_map_pass_specular
input: {name="Index", type="int"}
input: {name="Factor", type="float"}
input: {name="Mode", type="text"}
---

```{name="CODE", type="shader", restrict="fshader,main"}
  Specular= mix( Specular, $Mode$( Specular, val$Index$ ), $Factor$ );
```

---
node: 100_map_pass_mix
---

```{name="CODE", type="shader", restrict="fshader,main"}
  Normal = CalcBumpedNormal( vNormal, vTangent, vCotangent, Normal);
  Normal = normalize( view * vec4( Normal.xyz, 0 ));
```

---
node: 5000_map_pass_view_transform
---


```{name="CODE", type="shader", restrict="vshader,main"}
  vPosition = view * ( vPosition + Displace * vNormal );
```

---
node: 9990_map_pass_clip_transparency
input: {name="AlphaTreshhold", type="float"}
---

```{name="CODE", type="shader", restrict="fshader,main"}
  Color.a = step( $AlphaTreshhold$, Color.a );
```

---
node: 10000_map_pass_final
---


```{name="CODE", type="shader", restrict="vshader,main"}
//cameye = - ( view * Position ).xyz;
  gl_Position = proj * vPosition;
```

```{restrict="fshader,main"}
  FragColor = vec4( color_overlay_light( shadow.rgb, Color.rgb * vColor.rgb ) + spec.rgb * Specular.rgb, Color.a * vColor.a ); //(Normal.xyz + 1 )/2
  #if (__VERSION__ < 130)
  gl_FragColor = FragColor;
  #endif
```

